package dev.kuku.vfl.core;

import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.dtos.VFLBlockContext;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;

@Slf4j
public abstract class VFL {

    protected final AtomicBoolean blockStarted = new AtomicBoolean(false);

    public final void ensureBlockStarted() {
        // Use compare-and-set for atomic, thread-safe initialization
        if (blockStarted.compareAndSet(false, true)) {
            final VFLBlockContext context = getContext();
            final long startTimestamp = Instant.now().toEpochMilli();
            context.buffer.pushLogStartToBuffer(context.blockInfo.getId(), startTimestamp);
        }
    }

    public void close(String endMessage) {
        ensureBlockStarted();

        final VFLBlockContext context = getContext();
        final long endTimestamp = Instant.now().toEpochMilli();
        final BlockEndData endData = new BlockEndData(endTimestamp, endMessage);

        context.buffer.pushLogEndToBuffer(context.blockInfo.getId(), endData);
    }

    private void logInternal(LogTypeEnum type, String message) {
        // Ensure the log block is started before writing any entries
        ensureBlockStarted();

        final VFLBlockContext context = getContext();

        // Create and push the new log entry using the specified type and current sequence
        final var createdLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                context.blockInfo.getId(),
                context.currentLogId,
                type,
                message,
                context.buffer
        );

        // Update the current log id to maintain proper sequencing for subsequent logs
        context.currentLogId = createdLog.getId();
    }

    private <R> R logFnInternal(LogTypeEnum type, Supplier<R> fn, Function<R, String> messageSerializer) {
        // Execute the function and capture its result
        final R result = fn.get();

        // Convert the result to a log message using the provided serializer
        final String message = messageSerializer.apply(result);

        // Log the message with the specified type
        logInternal(type, message);

        // Return the original result, allowing for method chaining
        return result;
    }

    // ========== PUBLIC LOGGING METHODS ==========
    // These methods provide the public API for different logging scenarios

    public final void info(String message) {
        logInternal(LogTypeEnum.MESSAGE, message);
    }

    /**
     * Executes a function and logs its result at the MESSAGE level.
     * This is useful for logging the outcome of operations without disrupting the flow.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to a log message
     * @return The result of the executed function
     */
    public final <R> R infoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.MESSAGE, fn, messageSerializer);
    }

    /**
     * Logs a warning message at the WARN level.
     *
     * @param message The warning message to log
     */
    public final void warn(String message) {
        logInternal(LogTypeEnum.WARN, message);
    }

    /**
     * Executes a function and logs its result at the WARN level.
     * Useful for operations that complete successfully but with concerning outcomes.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to a warning message
     * @return The result of the executed function
     */
    public final <R> R warnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.WARN, fn, messageSerializer);
    }

    /**
     * Logs an error message at the ERROR level.
     *
     * @param message The error message to log
     */
    public final void error(String message) {
        logInternal(LogTypeEnum.ERROR, message);
    }

    public final Block publish(String publisherName, String message) {
        //Create publisher block
        Block publisherBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(publisherName, getContext().blockInfo.getId(), getContext().buffer);
        //Add log about publishing to the block
        SubBlockStartLog publisherBlockLog = VFLFlowHelper.CreateLogAndPush2Buffer(getContext().blockInfo.getId(),
                getContext().currentLogId,
                message, publisherBlock.getId(),
                LogTypeBlockStartEnum.PUBLISH_EVENT,
                getContext().buffer);
        //Update the flow
        getContext().currentLogId = publisherBlock.getId();
        return publisherBlock;
    }

    /**
     * Executes a function and logs its result at the ERROR level.
     * Useful for operations that fail or produce error conditions while still returning a value.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to an error message
     * @return The result of the executed function
     */
    public final <R> R errorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.ERROR, fn, messageSerializer);
    }

    /**
     * Abstract method that subclasses must implement to provide the logging context.
     * The context contains essential information including:
     * - Block information (ID, metadata)
     * - Current log sequence ID
     * - Buffer for storing log entries
     *
     * @return The VFLBlockContext containing all necessary logging state
     */
    protected abstract VFLBlockContext getContext();
}

package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

public interface VFLBuffer {
    /**
     * Add a log entry to the buffer (fire-and-forget).
     */
    void pushLogToBuffer(Log log);

    /**
     * Add a block entry to the buffer (fire-and-forget).
     */
    void pushBlockToBuffer(Block block);

    /**
     * Log that has started needs to be pushed
     */
    void pushLogStartToBuffer(String blockId, long timestamp);

    /**
     * Log that has ended needs to be pushed
     */
    void pushLogEndToBuffer(String blockId, BlockEndData endData);

    /**
     * Will flush all pending data and then shutdown
     */
    void flushAndClose();
}

package dev.kuku.vfl.core.dtos;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

import java.util.concurrent.atomic.AtomicBoolean;

@RequiredArgsConstructor
@ToString
public class VFLBlockContext {
    public final Block blockInfo;
    public final AtomicBoolean blockStarted = new AtomicBoolean(false);
    public final VFLBuffer buffer;
    public String currentLogId;
}
package dev.kuku.vfl.core.helpers;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.Log;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import dev.kuku.vfl.core.VFL;

import java.time.Instant;
import java.util.function.Function;
import java.util.function.Supplier;

import static dev.kuku.vfl.core.helpers.Util.UID;

public class VFLFlowHelper {

    public static Log CreateLogAndPush2Buffer(String blockId, String parentLogId, LogTypeEnum logType, String message, VFLBuffer buffer) {
        Log l = new Log(UID(), blockId, parentLogId, logType, message, Instant.now().toEpochMilli());
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static SubBlockStartLog CreateLogAndPush2Buffer(String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType, VFLBuffer buffer) {
        SubBlockStartLog l = new SubBlockStartLog(UID(), blockId, parentLogId, startMessage, referencedBlockId, logType);
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static Block CreateBlockAndPush2Buffer(String blockName, String parentBlockId, VFLBuffer buffer) {
        Block b = new Block(UID(), parentBlockId, blockName);
        buffer.pushBlockToBuffer(b);
        return b;
    }

    public static <R> R CallFnWithLogger(Supplier<R> supplier, VFL logger, Function<R, String> endMessageSerializer) {
        R result = null;
        try {
            result = supplier.get();
            return result;
        } catch (Exception e) {
            logger.error("Exception occurred: " + e.getClass().getSimpleName() + ": " + e.getMessage());
            throw e;
        } finally {
            String endMsg = CreateEndMessage(result, endMessageSerializer);
            logger.close(endMsg);
        }
    }

    private static <R> String CreateEndMessage(R result, Function<R, String> serializer) {
        if (serializer == null) return null;

        try {
            return serializer.apply(result);
        } catch (Exception e) {
            return "Failed to serialize end message: " + e.getMessage();
        }
    }


}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.VFL;
import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.dtos.VFLBlockContext;
import dev.kuku.vfl.core.helpers.Util;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Stack;

import static dev.kuku.vfl.core.helpers.Util.GetThreadInfo;
import static dev.kuku.vfl.core.helpers.Util.TrimId;
import static dev.kuku.vfl.core.helpers.VFLFlowHelper.CreateBlockAndPush2Buffer;
import static dev.kuku.vfl.core.helpers.VFLFlowHelper.CreateLogAndPush2Buffer;

/**
 * Provides context that is persistent per thread and manages VFL context operations
 */
public class ContextManager {
    public static final Logger log = LoggerFactory.getLogger(ContextManager.class);

    public static final ThreadLocal<Stack<VFLBlockContext>> loggerCtxStack = new ThreadLocal<>();
    public static final ThreadLocal<SpawnedThreadContext> spawnedThreadContext = new ThreadLocal<>();
    public static VFLBuffer AnnotationBuffer;

    /**
     * Gets the current context from the stack
     */
    public static VFLBlockContext getCurrentContext() {
        Stack<VFLBlockContext> stack = loggerCtxStack.get();
        return stack != null && !stack.isEmpty() ? stack.peek() : null;
    }

    /**
     * Checks if the current thread has an active context stack
     */
    public static boolean hasActiveContext() {
        return loggerCtxStack.get() != null;
    }    public static VFL logger = new VFL() {
        @Override
        protected VFLBlockContext getContext() {
            //If attempting to log in a new thread with no logger context stack, create a new sub block call.
            //Users MUST use VFLFutures for this operation because VFLFutures clean up the left-over lambdas
            if (!hasActiveContext() && isSpawnedThread()) {
                startSubBlockFromSpawnedThreadContext(Thread.currentThread().getName() + "_" + Thread.currentThread().getId());
            }
            return getCurrentContext();
        }
    };

    /**
     * Checks if the current thread is a spawned thread with context
     */
    public static boolean isSpawnedThread() {
        return spawnedThreadContext.get() != null;
    }

    /**
     * Initializes a new context stack for the current thread
     */
    private static void initializeContextStack() {
        loggerCtxStack.set(new Stack<>());
    }

    /**
     * Pushes a new context to the stack
     */
    private static void pushContext(VFLBlockContext context) {
        if (loggerCtxStack.get() == null) {
            initializeContextStack();
        }
        loggerCtxStack.get().push(context);
    }

    /**
     * Creates and starts a root block context
     */
    public static void startRootBlock(String blockName) {
        Block rootBlock = CreateBlockAndPush2Buffer(blockName, null, AnnotationBuffer);
        VFLBlockContext rootContext = new VFLBlockContext(rootBlock, AnnotationBuffer);

        initializeContextStack();
        pushContext(rootContext);
        spawnedThreadContext.remove(); //Remove left over spawnedThreadContext if any. Should always be clean but still
        logger.ensureBlockStarted();

        log.debug("[VFL] Started root block: {}-{} in thread {}",
                rootBlock.getBlockName(), TrimId(rootBlock.getId()), GetThreadInfo());
    }

    public static void startSubBlockFromSpawnedThreadContext(String blockName) {
        SpawnedThreadContext callerData = spawnedThreadContext.get();
        log.debug("Starting sub block {} from spawned thread context {}-{}", blockName, callerData.parentContext().blockInfo.getBlockName(), Util.TrimId(callerData.parentContext().blockInfo.getId()));

        // Create sub block in new thread
        Block subBlockNewThread = CreateBlockAndPush2Buffer(
                blockName,
                callerData.parentContext().blockInfo.getId(),
                AnnotationBuffer
        );

        // Create sub block start log and add it to caller's log
        CreateLogAndPush2Buffer(
                callerData.parentContext().blockInfo.getId(),
                callerData.parentContext().currentLogId,
                null,
                subBlockNewThread.getId(),
                callerData.startType(),
                AnnotationBuffer
        );

        // Create context for started sub block and push it to stack
        VFLBlockContext currentContext = new VFLBlockContext(subBlockNewThread, AnnotationBuffer);
        initializeContextStack();
        pushContext(currentContext);
        logger.ensureBlockStarted();

        log.debug("[VFL] Started spawned thread block: {}-{} in thread {}",
                subBlockNewThread.getBlockName(), TrimId(subBlockNewThread.getId()), GetThreadInfo());
    }

    /**
     * Creates and starts a sub block context
     */
    public static void startSubBlock(String blockName) {
        VFLBlockContext parentContext = getCurrentContext();

        // Create sub block
        assert parentContext != null;
        Block primarySubBlockStart = CreateBlockAndPush2Buffer(
                blockName,
                parentContext.blockInfo.getId(),
                AnnotationBuffer
        );

        // Create sub block start log and add it to caller's log
        SubBlockStartLog subBlockStartLog = CreateLogAndPush2Buffer(
                parentContext.blockInfo.getId(),
                parentContext.currentLogId,
                null,
                primarySubBlockStart.getId(),
                LogTypeBlockStartEnum.SUB_BLOCK_START_PRIMARY,
                AnnotationBuffer
        );

        // Move forward the flow
        parentContext.currentLogId = subBlockStartLog.getId();

        // Create context for started sub block and push it to stack
        VFLBlockContext currentContext = new VFLBlockContext(primarySubBlockStart, AnnotationBuffer);
        pushContext(currentContext);
        logger.ensureBlockStarted();

        log.debug("[VFL] Started sub block: {}-{} in thread {}",
                primarySubBlockStart.getBlockName(), TrimId(primarySubBlockStart.getId()), GetThreadInfo());
    }

    /**
     * Logs an exception for the current context
     */
    public static void logException(Throwable exception) {
        VFLBlockContext currentCtx = getCurrentContext();
        if (currentCtx != null && exception != null) {
            logger.error(String.format("Exception : %s %s-%s in thread %s",
                    exception.getClass() + "_" + exception.getMessage(),
                    currentCtx.blockInfo.getBlockName(),
                    TrimId(currentCtx.blockInfo.getId()),
                    GetThreadInfo()));
        }
    }

    /**
     * Closes the current context and performs cleanup
     */
    public static void closeCurrentContext(Object returnValue) {
        // Close the logger context
        logger.close("Returning " + returnValue);

        // Pop the context
        Stack<VFLBlockContext> stack = loggerCtxStack.get();
        if (stack != null && !stack.isEmpty()) {
            VFLBlockContext poppedContext = stack.pop();
            log.debug("[VFL] Popped : {}-{} in thread {}",
                    poppedContext.blockInfo.getBlockName(),
                    TrimId(poppedContext.blockInfo.getId()),
                    GetThreadInfo());

            // Clean up if stack is empty
            if (stack.isEmpty()) {
                cleanupThreadContext(poppedContext);
            }
        } else {
            log.warn("[VFL] Stack is empty or null when it shouldn't be");
        }
    }

    /**
     * Cleans up thread-local resources when the context stack is empty
     */
    private static void cleanupThreadContext(VFLBlockContext lastContext) {
        boolean isRootThread = !isSpawnedThread();

        if (isRootThread) {
            log.debug("[VFL] COMPLETE: Operation Flow complete for {}-{} in Thread {}",
                    lastContext.blockInfo.getBlockName(),
                    TrimId(lastContext.blockInfo.getId()),
                    GetThreadInfo());
            AnnotationBuffer.flushAndClose();
        }

        log.debug("[VFL] EMPTIED STACK N SPAWNED CONTEXT: in thread {}", GetThreadInfo());

        // Clean up thread-local resources
        loggerCtxStack.remove();
        spawnedThreadContext.remove();
    }

    /**
     * Checks if the current thread's context stack is empty
     */
    public static boolean isContextStackEmpty() {
        Stack<VFLBlockContext> stack = loggerCtxStack.get();
        return stack == null || stack.isEmpty();
    }




}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.helpers.Util;

import java.util.function.Function;
import java.util.function.Supplier;

public class Log {
    // ================ INFO METHODS ================
    public static void Info(String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return;
        ContextManager.logger.info(Util.FormatMessage(message, args));
    }

    public static <R> R InfoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        return ContextManager.logger.infoFn(fn, messageSerializer);
    }

    public static <R> R InfoFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return ContextManager.logger.infoFn(fn, s);
    }

    public static void InfoFn(Runnable runnable, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        ContextManager.logger.infoFn(supplier, s);
    }

    // ================ WARN METHODS ================
    public static void Warn(String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return;
        ContextManager.logger.warn(Util.FormatMessage(message, args));
    }

    public static <R> R WarnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        return ContextManager.logger.warnFn(fn, messageSerializer);
    }

    public static <R> R WarnFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return ContextManager.logger.warnFn(fn, s);
    }

    public static void WarnFn(Runnable runnable, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        ContextManager.logger.warnFn(supplier, s);
    }

    // ================ ERROR METHODS ================
    public static void Error(String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return;
        ContextManager.logger.error(Util.FormatMessage(message, args));
    }

    public static <R> R ErrorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        return ContextManager.logger.errorFn(fn, messageSerializer);
    }

    public static <R> R ErrorFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) return fn.get();
        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return ContextManager.logger.errorFn(fn, s);
    }

    public static void ErrorFn(Runnable runnable, String message, Object... args) {
        if (!VFLAnnotationProcessor.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        ContextManager.logger.errorFn(supplier, s);
    }
}


package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.VFLBlockContext;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;

public record SpawnedThreadContext(VFLBlockContext parentContext, LogTypeBlockStartEnum startType) {
}
package dev.kuku.vfl.impl.annotation;

import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bytecode.assign.Assigner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Method;

import static dev.kuku.vfl.core.helpers.Util.GetMethodName;

public class VFLAnnotationAdvice {
    public static final Logger log = LoggerFactory.getLogger(VFLAnnotationAdvice.class);

    @Advice.OnMethodEnter
    public static void onEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] args) {
        String blockName = GetMethodName(method, args);
        if (!ContextManager.hasActiveContext()) {
            if (ContextManager.isSpawnedThread()) {
                ContextManager.startSubBlockFromSpawnedThreadContext(blockName);
            } else {
                ContextManager.startRootBlock(blockName);
            }
        } else {
            ContextManager.startSubBlock(blockName);
        }
    }

    @Advice.OnMethodExit(onThrowable = Throwable.class)
    public static void onExit(@Advice.Origin Method method,
                              @Advice.AllArguments Object[] args,
                              @Advice.Return(typing = Assigner.Typing.DYNAMIC) Object returnedValue,
                              @Advice.Thrown Throwable threw) {

        // Log exception if present
        ContextManager.logException(threw);

        // Close current context and perform cleanup
        ContextManager.closeCurrentContext(returnedValue);
    }
}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.agent.builder.AgentBuilder;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.matcher.ElementMatchers;
import net.bytebuddy.utility.JavaModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.instrument.Instrumentation;

public class VFLAnnotationProcessor {
    public static Logger log = LoggerFactory.getLogger(VFLAnnotationProcessor.class);

    public static volatile boolean initialized = false;

    public static synchronized void initialise(VFLBuffer buffer) {
        try {
            Instrumentation inst = ByteBuddyAgent.install();
            ContextManager.AnnotationBuffer = buffer;

            new AgentBuilder.Default()
                    .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                    .with(new AgentBuilder.Listener() {
                        @Override
                        public void onDiscovery(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {
                            // Called when a type is discovered for transformation
                        }

                        @Override
                        public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader,
                                                     JavaModule module, boolean loaded, DynamicType dynamicType) {
                            log.debug("[VFL] Successfully transformed: {}", typeDescription.getName());
                        }

                        @Override
                        public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader,
                                              JavaModule module, boolean loaded) {
                            // Called when a type is ignored
                        }

                        @Override
                        public void onError(String typeName, ClassLoader classLoader, JavaModule module,
                                            boolean loaded, Throwable throwable) {
                            log.error("[VFL] Error transforming: {}", typeName, throwable);
                        }

                        @Override
                        public void onComplete(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {
                            // Called when transformation is complete
                        }
                    })
                    // Target classes that declare methods with @VFLBlock annotation
                    .type(ElementMatchers.declaresMethod(ElementMatchers.isAnnotatedWith(VFLBlock.class)))
                    .transform((builder, typeDescription, classLoader, javaModule, protectionDomain) -> {
                        log.debug("[VFL] Attempting to instrument: {}", typeDescription.getName());
                        return builder.visit(
                                Advice.to(VFLAnnotationAdvice.class)
                                        .on(ElementMatchers.isAnnotatedWith(VFLBlock.class)
                                                .and(ElementMatchers.not(ElementMatchers.isAbstract())) // Exclude abstract methods
                                        )
                        );
                    })
                    .installOn(inst);

            initialized = true;
            log.info("[VFL] Instrumentation initialised successfully");

            // Log some debug information
            log.debug("[VFL] ByteBuddy Agent installed: {}", inst != null);
            log.debug("[VFL] VFLBuffer set: {}", ContextManager.AnnotationBuffer != null);

        } catch (Exception e) {
            log.error("[VFL] Initialisation failed", e);
            throw new RuntimeException(e);
        }
    }
}

package dev.kuku.vfl.impl.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for method to mark it as a block
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface VFLBlock {
    String blockName() default "";
}
package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.helpers.Util;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.Supplier;

import static dev.kuku.vfl.core.helpers.Util.GetThreadInfo;
import static dev.kuku.vfl.impl.annotation.ThreadContextManager.loggerCtxStack;
import static dev.kuku.vfl.impl.annotation.ThreadContextManager.spawnedThreadContext;

@Slf4j
public class VFLFutures {
    private static SpawnedThreadContext createSpawnedThreadContext() {
        return new SpawnedThreadContext(
                ContextManager.getCurrentContext(),
                LogTypeBlockStartEnum.SUB_BLOCK_START_SECONDARY_JOIN
        );
    }

    /**
     * Common logic for setting up spawned thread context
     */
    private static void setupSpawnedThreadContext(SpawnedThreadContext spawnedThreadContext) {
        if (!VFLAnnotationProcessor.initialized) return;

        log.debug("Spawned thread context: {}-{}", spawnedThreadContext.parentContext().blockInfo.getBlockName(), Util.TrimId(spawnedThreadContext.parentContext().blockInfo.getId()));

        var existingCtx = ContextManager.spawnedThreadContext.get();
        if (existingCtx != null) {
            log.warn("Spawned Thread Context is not null! {}", GetThreadInfo());
        }
        ContextManager.spawnedThreadContext.set(spawnedThreadContext);
    }

    /**
     * Wraps a supplier with VFL context setup
     */
    private static <R> Supplier<R> wrapSupplier(Supplier<R> supplier) {
        var spawnedThreadCtx = createSpawnedThreadContext();
        return () -> {
            try {
                setupSpawnedThreadContext(spawnedThreadCtx);
                return supplier.get();
            } finally {
                //If user Logs inside the lambda but not within a VFL block then a lambda sub block start step is created as part of the flow which is NOT removed by context manager as CM only managers methods that are annotated with @VFLBlock and needs to be removed manually.
                loggerCtxStack.remove();
                spawnedThreadContext.remove();
            }
        };
    }

    /**
     * Wraps a runnable with VFL context setup
     */
    private static Runnable wrapRunnable(Runnable runnable) {
        var spawnedThreadCtx = createSpawnedThreadContext();
        return () -> {
            try {
                setupSpawnedThreadContext(spawnedThreadCtx);
                runnable.run();

            } finally {
                //If user Logs inside the lambda but not within a VFL block then a lambda sub block start step is created as part of the flow which is NOT removed by context manager as CM only managers methods that are annotated with @VFLBlock and needs to be removed manually.
                loggerCtxStack.remove();
                spawnedThreadContext.remove();
            }
        };
    }

    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier, Executor executor) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier), executor);
    }

    // ================ PUBLIC API ================

    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier));
    }

    public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
        return CompletableFuture.runAsync(wrapRunnable(runnable), executor);
    }

    public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return CompletableFuture.runAsync(wrapRunnable(runnable));
    }


}

package dev.kuku.vfl.core.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class Block {
    private String id;
    private String parentBlockId;
    private String blockName;
}

package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Primitive Log that is simple in nature.
 */
@Getter
@RequiredArgsConstructor
public class Log {
    private final String id;
    private final String blockId;
    private final String parentLogId;
    private final LogType logType;
    private final String message;
    private final long timestamp;

    public Log(String id, String blockId, String parentLogId, LogTypeEnum logType, String message, long timestamp) {

        this.id = id;
        this.blockId = blockId;
        this.parentLogId = parentLogId;
        this.logType = new LogType(logType);
        this.message = message;
        this.timestamp = timestamp;
    }
}

package dev.kuku.vfl.core.models.logs;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;

public class LogType {
    public final String value;

    public LogType(LogTypeEnum logType) {
        this.value = logType.toString();
    }

    public LogType(LogTypeBlockStartEnum logType) {
        this.value = logType.toString();
    }

    // Private constructor for Jackson deserialization
    private LogType(String value) {
        this.value = value;
    }

    @JsonValue  // This tells Jackson to serialize this object as just the string value
    @Override
    public String toString() {
        return this.value;
    }

    @JsonCreator  // This tells Jackson how to create the object from a string
    public static LogType fromString(String value) {
        return new LogType(value);
    }
}

package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.Getter;

import java.time.Instant;

/**
 * Sub block start log following block's flow chain.
 */
@Getter
public class SubBlockStartLog extends Log {
    //The block that is being started
    private final String referencedBlockId;

    public SubBlockStartLog(String id, String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType) {
        super(id, blockId, parentLogId, new LogType(logType), startMessage, Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }

    public SubBlockStartLog(Log log, String referencedBlockId, LogTypeBlockStartEnum logTypeBlockStartEnum) {
        super(log.getId(), log.getBlockId(), log.getParentLogId(), new LogType(logTypeBlockStartEnum), log.getMessage(), Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }
}
package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeBlockStartEnum {
    SUB_BLOCK_START_PRIMARY("SUB_BLOCK_START_PRIMARY"),
    SUB_BLOCK_START_SECONDARY_NO_JOIN("SUB_BLOCK_START_SECONDARY_NO_JOIN"),
    PUBLISH_EVENT("PUBLISH_EVENT"),
    SUB_BLOCK_START_SECONDARY_JOIN("SUB_BLOCK_START_SECONDARY_JOIN"),
    EVENT_LISTENER("EVENT_LISTENER");

    private final String displayName;

    // Constructor to set the display name
    LogTypeBlockStartEnum(String displayName) {
        this.displayName = displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}
package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeEnum {
    MESSAGE("MESSAGE"),
    WARN("WARN"),
    ERROR("ERROR");

    private final String DisplayName;

    LogTypeEnum(String displayName) {
        DisplayName = displayName;
    }
}

//example
package threadvfl;

import dev.kuku.vfl.core.buffer.AsyncBuffer;
import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.buffer.flushHandler.NestedJsonFlushHandler;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.impl.annotation.Log;
import dev.kuku.vfl.impl.annotation.VFLInitializer;
import dev.kuku.vfl.impl.annotation.SubBlock;
import dev.kuku.vfl.impl.annotation.VFLFutures;
import org.junit.jupiter.api.Test;

import java.util.concurrent.Executors;

public class AnnotationTest {
    static VFLBuffer b;

    static VFLBuffer createBuffer(String fileName) {
        VFLFlushHandler f = new NestedJsonFlushHandler("test/output/" + AnnotationTest.class.getSimpleName() + "/" + fileName + ".json");
        return new AsyncBuffer(100, 3000, 100, f, Executors.newVirtualThreadPerTaskExecutor(), Executors.newSingleThreadScheduledExecutor());
        //return new NoOpsBuffer();
    }

    @Test
    void linear() {
        //VFLAnnotationProcessor.initialise(createBuffer("linear"));
        new TestService().linear();
    }

    @Test
    void async() {
        VFLAnnotationProcessor.initialise(createBuffer("async"));
        new TestService().async();
    }

}

class TestService {
    @VFLBlock
    private int square(int a) {
        return a * a;
    }

    @VFLBlock
    private int squareAndMultiply(int a, int b) {
        int num = a * b;
        return square(num);
    }

    @VFLBlock
    public void linear() {
        Log.Info("SUP");
        int a = Log.InfoFn(() -> square(12), "Squaring {} = {}", 12);
        int b = squareAndMultiply(a, 2);
        square(b);
    }

    @VFLBlock
    public void async() {
        Log.Info("SUP");
        var e = Executors.newFixedThreadPool(1);
        var t = VFLFutures.runAsync(() -> {
            Log.Info("CRASH");
            square(1);
        }, e);
        var t2 = VFLFutures.runAsync(() -> square(1), e);
        var t3 = VFLFutures.runAsync(() -> square(1), e);
        t.join();
        t2.join();
        t3.join();
    }

}


Here is a part of our codebase. our goal is to come up with a design for event listener logging and distrivbuted system logging

if you need reference to more files let me know for our goal
flush and all those logic are not important

notice how we are using annotation based approach

before we even start coding we need to come up with a design ok and discuss it

Anyways, we have introduced event publisher logging and we now need to implement event listener

the way its going to be hierarchically is for all started event listeners for that event publusher block i.e the parent of the event  listener block will have the publisher block as the parent id

secondly the event publisher to event listner hierarchy will be flat
so if thre is an event published and 3 event listeners for it
it wil show up as eventpublisher->eventlistner1, eventpublisher->eventlistenr2, eventpublisher->eventlistner3
not as eventpublisher->listner1->linstener2 and so on
they all have the publisher as the panret

so we can pass the publisher block to the event listener and it can use that info to start event listner BUT i want this process to be seamless and as automated as possible without user intervention

preferably a byte biddy advice + annotation?
if its marked with VFLEventListener then we can scan the parameters to find block and then start an event from it

let me know what you think about this

update :-
this is the answer we came up with
Looking at our discussion, here's the solution design for both Event-Driven Architecture (EDA) and Distributed System logging:

## Solution Design Overview

### Core Concept
Use **Block ID as correlation ID** for both local event processing and distributed system communication. This leverages your existing thread-local stack infrastructure while extending it for cross-service scenarios.

## 1. Event-Driven Architecture (EDA) Design

### Publisher Side Flow
1. Method annotated with `@VFLBlock` executes normally
2. Inside the method, call `logger.publishEvent()` which:
   - Creates a publisher Block (like existing `publish()`)
   - Logs the publish event in current flow
   - Returns an `EventPayload` containing the Block ID as correlation ID
3. Developer emits this EventPayload to their event system (Kafka, RabbitMQ, etc.)

### Consumer Side Flow
1. Event consumer method annotated with `@VFLEventListener`
2. ByteBuddy advice intercepts the method and scans parameters for:
   - **Direct Block object**: For same-JVM scenarios
   - **EventPayload object**: For distributed/async scenarios
3. If EventPayload found:
   - Creates a "reference Block" using the correlation ID
   - Establishes parent-child relationship with remote publisher
   - Uses existing thread-local stack for context management
4. Event listener executes with proper VFL context

### Threading Model
- **Single-threaded consumer**: Events processed sequentially, perfect for thread-local stack
- **Same thread publisher/consumer**: Even simpler - just nested method calls
- **Different threads**: Each thread has its own stack, linked via correlation ID

## 2. Distributed System Design

### Service-to-Service Communication
1. **Calling Service**:
   - Creates publisher Block for the service call
   - Uses Block ID as correlation ID in HTTP headers/request payload
   - Logs the outbound service call

2. **Called Service**:
   - Method annotated with `@VFLBlock`
   - Extracts correlation ID from request
   - Starts root block with the correlation ID as parent reference
   - All subsequent logging linked to original caller

### Cross-Service Flow Visualization
```
Service A: processOrder
├─ PaymentService (publisher block)
│
Service B: (linked via correlation ID)
├─ PaymentService (reference block)
│  └─ handlePayment (actual processing)
```

## 3. ByteBuddy Advice Strategy

### Enhanced VFLEventListenerAdvice
- Scans method parameters in order of priority:
  1. Look for direct `Block` objects (local scenarios)
  2. Look for `EventPayload` with correlation ID (distributed events)
  3. Look for objects with correlation ID fields (service requests)
- Creates appropriate context based on what's found
- Fallback to regular sub-block if nothing found

### Parameter Detection Logic
- **Block object found**: Direct parent-child relationship
- **EventPayload found**: Create reference block from correlation ID
- **Request object with correlation ID**: Start root block with correlation
- **Nothing found**: Standard sub-block creation

## 4. Key Design Principles

### Automatic Detection
- Zero configuration - just add annotations
- ByteBuddy automatically detects the scenario based on method parameters
- Same annotation works for local, async, and distributed scenarios

### Thread Safety
- Uses existing thread-local stack infrastructure
- Each thread maintains its own context stack
- Correlation IDs safely passed between threads/services

### Unified Flow Visualization
- Local method calls and distributed events appear in same hierarchy
- Block ID serves dual purpose: local identifier + distributed correlation ID
- Seamless experience whether processing is sync, async, or cross-service

## 5. Usage Patterns

### Local Events (Same JVM)
```java
@VFLBlock
public void processOrder() {
    EventPayload event = logger.publishEvent("PaymentRequested", "Processing payment", orderData);
    // Emit to local event bus
}

@VFLEventListener
public void handlePayment(EventPayload event) {
    // Automatically linked via correlation ID
}
```

### Distributed Services
```java
@VFLBlock
public void callPaymentService(PaymentRequest request) {
    Block serviceCall = logger.publish("PaymentService", "Calling payment service");
    request.setCorrelationId(serviceCall.getId());
    // Make HTTP call with correlation ID
}

@VFLBlock // In remote service
public void processPayment(PaymentRequest request) {
    // Start with correlation ID from request
    // All logging linked to original caller
}
```

This design maintains the elegance and simplicity of your current system while extending it to handle both event-driven and distributed scenarios seamlessly.

Sources

now we need to figure out how to implement



here is my idea

@VFLListener for event listeners
and it's advice will scan method args for Publisher Block
If found it creates a new block and adds a listener starts log to the publisher block with null parentLogId since all listener will be root

that is easy

now for distributed tracing
need to send block as payload and then the receiveer needs to be annotated with @VFLBlock
VFL Block advice will be modified, now it will first scan for block if found then it will use that blockID as the starting point

sounds good?
