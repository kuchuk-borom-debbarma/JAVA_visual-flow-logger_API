

package dev.kuku.vfl.core.buffer.abstracts;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

public abstract class VFLBufferBase implements VFLBuffer {
    private final int bufferSize;
    private final ReentrantLock lock = new ReentrantLock();
    private final List<Log> logs2Flush;
    private final List<Block> blocks2Flush;
    private final Map<String, Long> blockStarts2Flush;
    private final Map<String, BlockEndData> blockEnds2Flush;

    public VFLBufferBase(int bufferSize) {
        this.bufferSize = bufferSize;
        logs2Flush = new ArrayList<>();
        blocks2Flush = new ArrayList<>();
        blockStarts2Flush = new HashMap<>();
        blockEnds2Flush = new HashMap<>();
    }

    @Override
    public void pushLogToBuffer(Log log) {
        lock.lock();
        try {
            this.logs2Flush.add(log);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushBlockToBuffer(Block block) {
        lock.lock();
        try {
            this.blocks2Flush.add(block);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushLogStartToBuffer(String blockId, long timestamp) {
        lock.lock();
        try {
            this.blockStarts2Flush.put(blockId, timestamp);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushLogEndToBuffer(String blockId, BlockEndData endData) {
        lock.lock();
        try {
            blockEnds2Flush.put(blockId, endData);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    private void flushIfFull() {
        lock.lock();
        boolean shouldFlush = false;
        try {
            int logsSize = logs2Flush.size();
            int blocksSize = blocks2Flush.size();
            int blockStartsSize = blockStarts2Flush.size();
            int blockEndsSize = blockEnds2Flush.size();
            int totalSize = logsSize + blocksSize + blockStartsSize + blockEndsSize;
            if (totalSize > bufferSize) {
                shouldFlush = true;
            }
        } finally {
            lock.unlock();
        }
        if (shouldFlush) {
            flushAll();
        }
    }

    protected void flushAll() {
        List<Log> logsToFlush;
        List<Block> blocksToFlush;
        Map<String, Long> blockStartsToFlush;
        Map<String, BlockEndData> blockEndsToFlush;

        // Minimize lock time - only hold lock while copying and clearing data
        lock.lock();
        try {
            logsToFlush = new ArrayList<>(logs2Flush);
            blocksToFlush = new ArrayList<>(blocks2Flush);
            blockStartsToFlush = new HashMap<>(blockStarts2Flush);
            blockEndsToFlush = new HashMap<>(blockEnds2Flush);
            logs2Flush.clear();
            blocks2Flush.clear();
            blockStarts2Flush.clear();
            blockEnds2Flush.clear();
        } finally {
            lock.unlock(); // Release lock BEFORE calling onFlushAll
        }

        // multiple threads can execute onFlushAll concurrently
        // since each has their own copy of the data
        onFlushAll(logsToFlush, blocksToFlush, blockStartsToFlush, blockEndsToFlush);
    }

    @Override
    public void flush() {
        flushAll();
    }

    protected abstract void onFlushAll(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds);
}

package dev.kuku.vfl.core.buffer.abstracts;

import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

public abstract class VFLBufferWithFlushHandlerBase extends VFLBufferBase {
    protected final VFLFlushHandler flushHandler;

    public VFLBufferWithFlushHandlerBase(int bufferSize, VFLFlushHandler flushHandler) {
        super(bufferSize);
        this.flushHandler = flushHandler;
    }

    @Override
    protected final void onFlushAll(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds) {
        // Delegate to subclass for execution strategy (sync vs async)
        executeFlushAll(logs, blocks, blockStarts, blockEnds);
    }

    @Override
    public void flush() {
        super.flush(); // Flush any remaining data
        flushHandler.closeFlushHandler(); // Clean up the flush handler
    }

    // Abstract method for subclasses to implement their execution strategy
    protected abstract void executeFlushAll(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds);

    // Helper method to perform ordered flushing - can be called by subclasses
    protected final void performOrderedFlush(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds) {
        // Enforced flush order: blocks -> block starts -> block ends -> logs
        if (!blocks.isEmpty()) {
            flushHandler.pushBlocksToServer(blocks);
        }
        if (!blockStarts.isEmpty()) {
            flushHandler.pushBlockStartsToServer(blockStarts);
        }
        if (!blockEnds.isEmpty()) {
            flushHandler.pushBlockEndsToServer(blockEnds);
        }
        if (!logs.isEmpty()) {
            flushHandler.pushLogsToServer(logs);
        }
    }
}

package dev.kuku.vfl.core.buffer.flushHandler;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * VFLFlushHandler implementation that generates nested JSON output showing hierarchical execution flow.
 * Creates a single JSON file with blocks and their nested log chains based on parent-child relationships.
 * NOT RECOMMENDED for production. Only use during development and testing.
 */
public class NestedJsonFlushHandler implements VFLFlushHandler {

    private final String outputFilePath;
    private final ObjectMapper objectMapper;
    private final DateTimeFormatter timeFormatter;

    // Data storage
    private final Map<String, Block> blocks = new ConcurrentHashMap<>();
    private final Map<String, Log> logs = new ConcurrentHashMap<>();
    private final Map<String, Long> blockStarts = new ConcurrentHashMap<>();
    private final Map<String, BlockEndData> blockEnds = new ConcurrentHashMap<>();

    public NestedJsonFlushHandler(String outputFilePath) {
        this.outputFilePath = outputFilePath;
        this.objectMapper = new ObjectMapper();
        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        this.timeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
                .withZone(ZoneId.systemDefault());
    }

    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        if (logs != null) {
            for (Log log : logs) {
                this.logs.put(log.getId(), log);
            }
        }
        return true;
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        if (blocks != null) {
            for (Block block : blocks) {
                this.blocks.put(block.getId(), block);
            }
        }
        return true;
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        if (blockStarts != null) {
            this.blockStarts.putAll(blockStarts);
        }
        return true;
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        if (blockEnds != null) {
            this.blockEnds.putAll(blockEnds);
        }
        return true;
    }

    @Override
    public void closeFlushHandler() {
        try {
            List<BlockJson> rootBlocks = buildNestedStructure();
            writeJsonToFile(rootBlocks);
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate nested JSON output", e);
        }
    }


    private List<BlockJson> buildNestedStructure() {
        // Find root blocks (blocks with no parent)
        List<Block> rootBlocksList = blocks.values().stream()
                .filter(block -> block.getParentBlockId() == null)
                .toList();

        List<BlockJson> result = new ArrayList<>();
        for (Block rootBlock : rootBlocksList) {
            result.add(buildBlockJson(rootBlock));
        }

        return result;
    }

    private BlockJson buildBlockJson(Block block) {
        BlockJson blockJson = new BlockJson();
        blockJson.blockId = block.getId();
        blockJson.parentBlockId = block.getParentBlockId();
        blockJson.name = block.getBlockName();

        // Format times and calculate duration
        Long startTime = blockStarts.get(block.getId());
        if (startTime != null) {
            blockJson.startTime = formatTime(startTime);
        }

        // Handle block end time and calculate duration
        BlockEndData blockEnd = blockEnds.get(block.getId());
        if (blockEnd != null) {
            blockJson.endTime = formatTime(blockEnd.getEndTime());
            blockJson.endMessage = blockEnd.getEndMessage();

            // Calculate duration if both start and end times are available
            if (startTime != null) {
                long duration = blockEnd.getEndTime() - startTime;
                blockJson.duration = formatDuration(duration);
            }
        }

        // Build logs chain for this block
        blockJson.logsChain = buildLogsChain(block.getId(), null);

        return blockJson;
    }

    private List<LogJson> buildLogsChain(String blockId, String parentLogId) {
        // Get all logs for this block with the specified parent log ID
        List<Log> blockLogs = logs.values().stream()
                .filter(log -> Objects.equals(log.getBlockId(), blockId))
                .filter(log -> Objects.equals(log.getParentLogId(), parentLogId))
                .sorted(Comparator.comparing(Log::getTimestamp))
                .toList();

        List<LogJson> logJsons = new ArrayList<>();

        for (Log log : blockLogs) {
            LogJson logJson = new LogJson();
            logJson.id = log.getId();
            logJson.type = log.getLogType().toString();
            logJson.message = log.getMessage();
            logJson.timestamp = formatTime(log.getTimestamp());

            // Handle SubBlockStartLog special case
            if (log instanceof SubBlockStartLog subBlockLog) {
                String referencedBlockId = subBlockLog.getReferencedBlockId();

                // Add duration and end message for sub-block logs
                Long subBlockStartTime = blockStarts.get(referencedBlockId);
                BlockEndData subBlockEnd = blockEnds.get(referencedBlockId);

                if (subBlockStartTime != null && subBlockEnd != null) {
                    long duration = subBlockEnd.getEndTime() - subBlockStartTime;
                    logJson.duration = formatDuration(duration);
                    logJson.endMessage = subBlockEnd.getEndMessage();
                }

                // Add referenced block
                Block referencedBlock = blocks.get(referencedBlockId);
                if (referencedBlock != null) {
                    logJson.referencedBlock = buildBlockJson(referencedBlock);
                }
            }

            // Build nested logs chain (logs that have this log as parent)
            List<LogJson> nestedLogs = buildLogsChain(blockId, log.getId());
            if (!nestedLogs.isEmpty()) {
                logJson.logsChain = nestedLogs;
            }

            logJsons.add(logJson);
        }

        return logJsons;
    }

    private String formatTime(long timestampMillis) {
        return timeFormatter.format(Instant.ofEpochMilli(timestampMillis));
    }

    private String formatDuration(long durationMillis) {
        if (durationMillis < 1000) {
            return durationMillis + "ms";
        } else if (durationMillis < 60000) {
            double seconds = durationMillis / 1000.0;
            return String.format("%.3fs", seconds);
        } else {
            long minutes = durationMillis / 60000;
            long remainingMs = durationMillis % 60000;
            double remainingSeconds = remainingMs / 1000.0;
            return String.format("%dmin %.3fs", minutes, remainingSeconds);
        }
    }

    private void writeJsonToFile(List<BlockJson> rootBlocks) throws IOException {
        File outputFile = new File(outputFilePath);

        // Create parent directories if they don't exist
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            if (!parentDir.mkdirs()) {
                throw new IOException("Failed to create parent directories for: " + outputFilePath);
            }
        }

        try (FileWriter writer = new FileWriter(outputFile)) {
            objectMapper.writeValue(writer, rootBlocks);
        }
    }

    // JSON data classes
    private static class BlockJson {
        public String blockId;
        public String parentBlockId;
        public String name;
        public String startTime;
        public String endTime;
        public String duration;
        public String endMessage;
        public List<LogJson> logsChain;
    }

    private static class LogJson {
        public String id;
        public String type;
        public String message;
        public String timestamp;
        public String duration; // Only for SubBlockStartLog
        public String endMessage; // Only for SubBlockStartLog
        public BlockJson referencedBlock; // Only for SubBlockStartLog
        public List<LogJson> logsChain; // Nested logs
    }

    @Override
    public String toString() {
        return "NestedJsonFlushHandler{" +
                "blocks=" + blocks +
                ", logs=" + logs +
                '}';
    }
}

package dev.kuku.vfl.core.buffer.flushHandler;

import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

public class NoOpsFlushHandler implements VFLFlushHandler {
    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        return true;
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        return true;
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        return true;
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        return true;
    }

    @Override
    public void closeFlushHandler() {

    }
}


package dev.kuku.vfl.core.buffer.flushHandler;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

public interface VFLFlushHandler {
    boolean pushLogsToServer(List<Log> logs);

    boolean pushBlocksToServer(List<Block> blocks);

    boolean pushBlockStartsToServer(Map<String, Long> blockStarts);

    boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds);

    void closeFlushHandler();
}

package dev.kuku.vfl.core.buffer.flushHandler;

import com.fasterxml.jackson.databind.ObjectMapper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Map;

/**
 * VFL Hub flush handler with blocking HttpClient. This is because the order at which the requests are made may or may not be important.
 * If used with AsyncBuffer this will not block main thread as it will be running in provided executor
 */
@Slf4j
@RequiredArgsConstructor
public class VFLHubFlushHandler implements VFLFlushHandler {
    private static final String ADD_LOGS_EP = "/logs";
    private static final String ADD_BLOCKS_EP = "/blocks";
    private static final String ADD_BLOCK_STARTS_EP = "/block-starts";
    private static final String ADD_BLOCK_ENDS_EP = "/block-ends";
    private static final String API_VERSION = "api/v1";
    private final URI url;
    private final HttpClient httpClient = HttpClient
            .newBuilder()
            .build();
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        log.debug("Attempting to push {} logs to server", logs.size());
        try {
            String jsonBody = objectMapper.writeValueAsString(logs);
            log.trace("Serialized logs to JSON: {} characters", jsonBody.length());

            HttpRequest request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                    .uri(URI.create(url + "/" + API_VERSION + ADD_LOGS_EP))
                    .header("Content-Type", "application/json")
                    .build();

            log.debug("Sending POST request to: {}", url + "/" + API_VERSION + ADD_LOGS_EP);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            boolean success = response.statusCode() >= 200 && response.statusCode() < 300;
            if (success) {
                log.debug("Successfully pushed logs to server. Status: {}", response.statusCode());
            } else {
                log.warn("Failed to push logs to server. Status: {}, Response: {}", response.statusCode(), response.body());
            }

            return success;
        } catch (IOException | InterruptedException e) {
            log.error("Error pushing logs to server", e);
            log.error(e.fillInStackTrace().toString());
            return false;
        }
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        log.debug("Attempting to push {} blocks to server", blocks.size());
        try {
            String jsonBody = objectMapper.writeValueAsString(blocks);
            log.trace("Serialized blocks to JSON: {} characters", jsonBody.length());

            HttpRequest request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                    .uri(URI.create(url + "/" + API_VERSION + ADD_BLOCKS_EP))
                    .header("Content-Type", "application/json")
                    .build();

            log.debug("Sending POST request to: {}", url + "/" + API_VERSION + ADD_BLOCKS_EP);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            boolean success = response.statusCode() >= 200 && response.statusCode() < 300;
            if (success) {
                log.debug("Successfully pushed blocks to server. Status: {}", response.statusCode());
            } else {
                log.warn("Failed to push blocks to server. Status: {}, Response: {}", response.statusCode(), response.body());
            }

            return success;
        } catch (IOException | InterruptedException e) {
            log.error("Error pushing blocks to server", e);
            log.error(e.fillInStackTrace().toString());
            return false;
        }
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        log.debug("Attempting to push {} block starts to server", blockStarts.size());
        try {
            String jsonBody = objectMapper.writeValueAsString(blockStarts);
            log.trace("Serialized block starts to JSON: {} characters", jsonBody.length());

            HttpRequest request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                    .uri(URI.create(url + "/" + API_VERSION + ADD_BLOCK_STARTS_EP))
                    .header("Content-Type", "application/json")
                    .build();

            log.debug("Sending POST request to: {}", url + "/" + API_VERSION + ADD_BLOCK_STARTS_EP);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            boolean success = response.statusCode() >= 200 && response.statusCode() < 300;
            if (success) {
                log.debug("Successfully pushed block starts to server. Status: {}", response.statusCode());
            } else {
                log.warn("Failed to push block starts to server. Status: {}, Response: {}", response.statusCode(), response.body());
            }

            return success;
        } catch (IOException | InterruptedException e) {
            log.error("Error pushing block starts to server", e);
            log.error(e.fillInStackTrace().toString());
            return false;
        }
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        log.debug("Attempting to push {} block ends to server", blockEnds.size());
        try {
            String jsonBody = objectMapper.writeValueAsString(blockEnds);
            log.trace("Serialized block ends to JSON: {} characters", jsonBody.length());

            HttpRequest request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                    .uri(URI.create(url + "/" + API_VERSION + ADD_BLOCK_ENDS_EP))
                    .header("Content-Type", "application/json")
                    .build();

            log.debug("Sending POST request to: {}", url + "/" + API_VERSION + "/blocks-ends");
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            boolean success = response.statusCode() >= 200 && response.statusCode() < 300;
            if (success) {
                log.debug("Successfully pushed block ends to server. Status: {}", response.statusCode());
            } else {
                log.warn("Failed to push block ends to server. Status: {}, Response: {}", response.statusCode(), response.body());
            }

            return success;
        } catch (IOException | InterruptedException e) {
            log.error("Error pushing block ends to server", e);
            log.error(e.fillInStackTrace().toString());
            return false;
        }
    }

    @Override
    public void closeFlushHandler() {
        // HttpClient doesn't have a close() method in standard Java 11+ implementation
        // It will be automatically cleaned up by garbage collection
    }
}

package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.buffer.abstracts.VFLBufferWithFlushHandlerBase;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Async buffer that uses executor to flush asynchronously. Also flushes periodically using scheduled executor
 */
@Slf4j
public class AsyncBuffer extends VFLBufferWithFlushHandlerBase {
    private final ExecutorService flushExecutor;
    private final ScheduledExecutorService periodicExecutor;
    private final int flushTimeout;

    public AsyncBuffer(int bufferSize, int finalFlushTimeoutMillisecond, int periodicFlushTimeMillisecond,
                       VFLFlushHandler flushHandler, ExecutorService bufferFlushExecutor,
                       ScheduledExecutorService periodicFlushExecutor) {
        super(bufferSize, flushHandler);
        this.flushExecutor = bufferFlushExecutor;
        this.periodicExecutor = periodicFlushExecutor;
        this.flushTimeout = finalFlushTimeoutMillisecond;
        periodicExecutor.scheduleWithFixedDelay(this::flushAll, periodicFlushTimeMillisecond, periodicFlushTimeMillisecond, TimeUnit.MILLISECONDS);
    }

    @Override
    protected void executeFlushAll(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds) {
        // Guard against shutdown executor
        if (flushExecutor.isShutdown()) {
            log.warn("Executor is shutdown, performing synchronous flush");
            performOrderedFlush(logs, blocks, blockStarts, blockEnds);
            return;
        }

        try {
            flushExecutor.submit(() -> performOrderedFlush(logs, blocks, blockStarts, blockEnds));
        } catch (RejectedExecutionException e) {
            log.warn("Task rejected by executor (likely shutting down), performing synchronous flush", e);
            performOrderedFlush(logs, blocks, blockStarts, blockEnds);
        }
    }

    @Override
    public void flush() {
        // First, stop the periodic executor to prevent new scheduled flushes
        periodicExecutor.shutdown();
        super.flushAll();
        // Now shutdown the flush executor
        flushExecutor.shutdown();

        try {
            int elapsed = 0;
            while (elapsed < flushTimeout) {
                if (flushExecutor.awaitTermination(100, TimeUnit.MILLISECONDS)) {
                    // Tasks completed successfully
                    log.debug("Finished flush executor shutdown. Closing flush handler.");
                    flushHandler.closeFlushHandler();
                    log.debug("Finished Complete flush");
                    return;
                }
                elapsed += 100;
            }

            // Timeout exceeded - force shutdown
            flushExecutor.shutdownNow();
            throw new RuntimeException("Flush timeout exceeded: " + flushTimeout + "ms");

        } catch (InterruptedException e) {
            flushExecutor.shutdownNow();
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted during shutdown", e);
        }
    }

    @Override
    public String toString() {
        return "AsyncBuffer{" +
                "flushTimeout=" + flushTimeout +
                ", flushHandler=" + flushHandler +
                ", periodicExecutor=" + periodicExecutor +
                ", flushExecutor=" + flushExecutor +
                '}';
    }
}
package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

public class NoOpsBuffer implements VFLBuffer {
    @Override
    public void pushLogToBuffer(Log log) {

    }

    @Override
    public void pushBlockToBuffer(Block block) {

    }

    @Override
    public void pushLogStartToBuffer(String blockId, long timestamp) {

    }

    @Override
    public void pushLogEndToBuffer(String blockId, BlockEndData endData) {

    }

    @Override
    public void flush() {

    }
}

package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.buffer.abstracts.VFLBufferWithFlushHandlerBase;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

/**
 * Synchronous logger that flushing in blocking fashion
 */
public class SynchronousBuffer extends VFLBufferWithFlushHandlerBase {
    public SynchronousBuffer(int bufferSize, VFLFlushHandler flushHandler) {
        super(bufferSize, flushHandler);
    }

    @Override
    protected void executeFlushAll(List<Log> logs, List<Block> blocks, Map<String, Long> blockStarts, Map<String, BlockEndData> blockEnds) {
        // Execute synchronously - directly call the ordered flush
        performOrderedFlush(logs, blocks, blockStarts, blockEnds);
    }
}

package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

public interface VFLBuffer {
    /**
     * Add a log entry to the buffer (fire-and-forget).
     */
    void pushLogToBuffer(Log log);

    /**
     * Add a block entry to the buffer (fire-and-forget).
     */
    void pushBlockToBuffer(Block block);

    /**
     * Log that has started needs to be pushed
     */
    void pushLogStartToBuffer(String blockId, long timestamp);

    /**
     * Log that has ended needs to be pushed
     */
    void pushLogEndToBuffer(String blockId, BlockEndData endData);

    /**
     * Will flush all pending data and then shutdown
     */
    void flush();
}
package dev.kuku.vfl.core.dtos;

import dev.kuku.vfl.core.models.Block;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

import java.util.concurrent.atomic.AtomicBoolean;

@RequiredArgsConstructor
@ToString
public class BlockContext {
    public final Block blockInfo;
    public final AtomicBoolean blockStarted = new AtomicBoolean(false);
    public String currentLogId;
}

package dev.kuku.vfl.core.dtos;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class BlockEndData {
    private Long endTime;
    private String endMessage;
}
package dev.kuku.vfl.core.dtos;

import dev.kuku.vfl.core.models.Block;

public record EventPublisherBlock(Block block) {
}

package dev.kuku.vfl.core.helpers;

import dev.kuku.vfl.impl.annotation.SubBlock;

import java.lang.reflect.Method;
import java.util.UUID;
import java.util.function.Function;

public class Util {
    public static String UID() {
        return UUID.randomUUID().toString();
    }

    public static String FormatMessage(String message, Object... args) {
        if (args == null || args.length == 0) {
            return message;
        }

        String result = message;
        for (Object arg : args) {
            if (result.contains("{}")) {
                result = result.replaceFirst("\\{}",
                        arg == null ? "null" : String.valueOf(arg));
            } else {
                break;
            }
        }
        return result;
    }

    /**
     * Combines user arguments with a return value into a single array.
     * The return value is appended as the last element.
     *
     * @param userArgs    The original arguments passed by the user
     * @param returnValue The return value to append
     * @return A new array containing all user args followed by the return value
     */
    public static Object[] CombineArgsWithReturn(Object[] userArgs, Object returnValue) {
        if (userArgs == null) {
            return new Object[]{returnValue};
        }

        Object[] combined = new Object[userArgs.length + 1];
        System.arraycopy(userArgs, 0, combined, 0, userArgs.length);
        combined[userArgs.length] = returnValue;
        return combined;
    }

    public static String GetThreadInfo() {
        Thread currentThread = Thread.currentThread();
        return String.format("[Thread: %s (ID: %d)]", currentThread.getName(), currentThread.threadId());
    }

    public static String TrimId(String fullId) {
        if (fullId == null) return "null";
        String[] parts = fullId.split("-");
        return parts.length > 0 ? parts[parts.length - 1] : fullId;
    }

    public static <R> Function<R, String> UpdateEndMsg(Function<R, String> msgSerializer, Object... args) {
        return (r) -> {
            // Get the message template from the user's serializer
            String messageTemplate = msgSerializer.apply(r);

            // Format the message with user args + return value
            // Args convention: user args fill {0}, {1}, {2}... and return value fills the last placeholder
            Object[] allArgs = Util.CombineArgsWithReturn(args, r);
            return Util.FormatMessage(messageTemplate, allArgs);
        };
    }


    public static String GetMethodName(Method method, Object[] args) {
        SubBlock anno = method.getAnnotation(SubBlock.class);
        if (anno != null && !anno.blockName().isEmpty()) {
            String name = anno.blockName();
            if (args != null) {
                for (int i = 0; i < args.length; i++) {
                    name = name.replace("{" + i + "}", String.valueOf(args[i]));
                }
            }
            return name;
        }

        StringBuilder sb = new StringBuilder(method.getName()).append('(');
        if (args != null) {
            for (int i = 0; i < args.length; i++) {
                if (i > 0) sb.append(", ");
                sb.append(args[i]);
            }
        }
        return sb.append(')').toString();
    }

}

package dev.kuku.vfl.core.helpers;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.Log;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import dev.kuku.vfl.core.VFL;

import java.time.Instant;
import java.util.function.Function;
import java.util.function.Supplier;

import static dev.kuku.vfl.core.helpers.Util.UID;

public class VFLFlowHelper {

    public static Log CreateLogAndPush2Buffer(String blockId, String parentLogId, LogTypeEnum logType, String message, VFLBuffer buffer) {
        Log l = new Log(UID(), blockId, parentLogId, logType, message, Instant.now().toEpochMilli());
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static SubBlockStartLog CreateLogAndPush2Buffer(String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType, VFLBuffer buffer) {
        SubBlockStartLog l = new SubBlockStartLog(UID(), blockId, parentLogId, startMessage, referencedBlockId, logType);
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static Block CreateBlockAndPush2Buffer(String blockName, String parentBlockId, VFLBuffer buffer) {
        Block b = new Block(UID(), parentBlockId, blockName);
        buffer.pushBlockToBuffer(b);
        return b;
    }

    public static <R> R CallFnWithLogger(Supplier<R> supplier, VFL logger, Function<R, String> endMessageSerializer) {
        R result = null;
        try {
            result = supplier.get();
            return result;
        } catch (Exception e) {
            logger.error("Exception occurred: " + e.getClass().getSimpleName() + ": " + e.getMessage());
            throw e;
        } finally {
            String endMsg = CreateEndMessage(result, endMessageSerializer);
            logger.close(endMsg);
        }
    }

    private static <R> String CreateEndMessage(R result, Function<R, String> serializer) {
        if (serializer == null) return null;

        try {
            return serializer.apply(result);
        } catch (Exception e) {
            return "Failed to serialize end message: " + e.getMessage();
        }
    }


}

package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeBlockStartEnum {
    SUB_BLOCK_START_PRIMARY("SUB_BLOCK_START_PRIMARY"),
    SUB_BLOCK_START_SECONDARY_NO_JOIN("SUB_BLOCK_START_SECONDARY_NO_JOIN"),
    PUBLISH_EVENT("PUBLISH_EVENT"),
    SUB_BLOCK_START_SECONDARY_JOIN("SUB_BLOCK_START_SECONDARY_JOIN"),
    EVENT_LISTENER("EVENT_LISTENER");

    private final String displayName;

    // Constructor to set the display name
    LogTypeBlockStartEnum(String displayName) {
        this.displayName = displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}
package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeEnum {
    MESSAGE("MESSAGE"),
    WARN("WARN"),
    ERROR("ERROR");

    private final String DisplayName;

    LogTypeEnum(String displayName) {
        DisplayName = displayName;
    }
}

package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Primitive Log that is simple in nature.
 */
@Getter
@RequiredArgsConstructor
public class Log {
    private final String id;
    private final String blockId;
    private final String parentLogId;
    private final LogType logType;
    private final String message;
    private final long timestamp;

    public Log(String id, String blockId, String parentLogId, LogTypeEnum logType, String message, long timestamp) {

        this.id = id;
        this.blockId = blockId;
        this.parentLogId = parentLogId;
        this.logType = new LogType(logType);
        this.message = message;
        this.timestamp = timestamp;
    }
}

package dev.kuku.vfl.core.models.logs;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;

public class LogType {
    public final String value;

    public LogType(LogTypeEnum logType) {
        this.value = logType.toString();
    }

    public LogType(LogTypeBlockStartEnum logType) {
        this.value = logType.toString();
    }

    // Private constructor for Jackson deserialization
    private LogType(String value) {
        this.value = value;
    }

    @JsonValue  // This tells Jackson to serialize this object as just the string value
    @Override
    public String toString() {
        return this.value;
    }

    @JsonCreator  // This tells Jackson how to create the object from a string
    public static LogType fromString(String value) {
        return new LogType(value);
    }
}

package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.Getter;

import java.time.Instant;

/**
 * Sub block start log following block's flow chain.
 */
@Getter
public class SubBlockStartLog extends Log {
    //The block that is being started
    private final String referencedBlockId;

    public SubBlockStartLog(String id, String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType) {
        super(id, blockId, parentLogId, new LogType(logType), startMessage, Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }

    public SubBlockStartLog(Log log, String referencedBlockId, LogTypeBlockStartEnum logTypeBlockStartEnum) {
        super(log.getId(), log.getBlockId(), log.getParentLogId(), new LogType(logTypeBlockStartEnum), log.getMessage(), Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }
}

package dev.kuku.vfl.core.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class Block {
    private String id;
    private String parentBlockId;
    private String blockName;
}

package dev.kuku.vfl.core;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;

@Slf4j
public abstract class VFL {

    protected final AtomicBoolean blockStarted = new AtomicBoolean(false);

    public final void ensureBlockStarted() {
        // Use compare-and-set for atomic, thread-safe initialization
        if (blockStarted.compareAndSet(false, true)) {
            final BlockContext context = getContext();
            final long startTimestamp = Instant.now().toEpochMilli();
            getBuffer().pushLogStartToBuffer(context.blockInfo.getId(), startTimestamp);
        }
    }

    public void close(String endMessage) {
        ensureBlockStarted();

        final BlockContext context = getContext();
        final long endTimestamp = Instant.now().toEpochMilli();
        final BlockEndData endData = new BlockEndData(endTimestamp, endMessage);

        getBuffer().pushLogEndToBuffer(context.blockInfo.getId(), endData);
    }

    private void logInternal(LogTypeEnum type, String message) {
        // Ensure the log block is started before writing any entries
        ensureBlockStarted();

        final BlockContext context = getContext();

        // Create and push the new log entry using the specified type and current sequence
        final var createdLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                context.blockInfo.getId(),
                context.currentLogId,
                type,
                message,
                getBuffer()
        );

        // Update the current log id to maintain proper sequencing for subsequent logs
        context.currentLogId = createdLog.getId();
    }

    private <R> R logFnInternal(LogTypeEnum type, Supplier<R> fn, Function<R, String> messageSerializer) {
        // Execute the function and capture its result
        final R result = fn.get();

        // Convert the result to a log message using the provided serializer
        final String message = messageSerializer.apply(result);

        // Log the message with the specified type
        logInternal(type, message);

        // Return the original result, allowing for method chaining
        return result;
    }

    // ========== PUBLIC LOGGING METHODS ==========
    // These methods provide the public API for different logging scenarios

    public final void info(String message) {
        logInternal(LogTypeEnum.MESSAGE, message);
    }

    /**
     * Executes a function and logs its result at the MESSAGE level.
     * This is useful for logging the outcome of operations without disrupting the flow.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to a log message
     * @return The result of the executed function
     */
    public final <R> R infoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.MESSAGE, fn, messageSerializer);
    }

    /**
     * Logs a warning message at the WARN level.
     *
     * @param message The warning message to log
     */
    public final void warn(String message) {
        logInternal(LogTypeEnum.WARN, message);
    }

    /**
     * Executes a function and logs its result at the WARN level.
     * Useful for operations that complete successfully but with concerning outcomes.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to a warning message
     * @return The result of the executed function
     */
    public final <R> R warnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.WARN, fn, messageSerializer);
    }

    /**
     * Executes a function and logs its result at the ERROR level.
     * Useful for operations that fail or produce error conditions while still returning a value.
     *
     * @param <R>               The return type of the function
     * @param fn                The function to execute
     * @param messageSerializer Function to convert the result to an error message
     * @return The result of the executed function
     */
    public final <R> R errorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.ERROR, fn, messageSerializer);
    }

    /**
     * Logs an error message at the ERROR level.
     *
     * @param message The error message to log
     */
    public final void error(String message) {
        logInternal(LogTypeEnum.ERROR, message);
    }

    public final Block publish(String publisherName, String message) {
        //Create publisher block
        Block publisherBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(publisherName, getContext().blockInfo.getId(), getBuffer());
        //Add log about publishing to the block
        SubBlockStartLog publisherBlockLog = VFLFlowHelper.CreateLogAndPush2Buffer(getContext().blockInfo.getId(),
                getContext().currentLogId,
                message, publisherBlock.getId(),
                LogTypeBlockStartEnum.PUBLISH_EVENT,
                getBuffer());
        //Update the flow
        getContext().currentLogId = publisherBlock.getId();
        return publisherBlock;
    }

    /**
     * Abstract method that subclasses must implement to provide the logging context.
     * The context contains essential information including:
     * - Block information (ID, metadata)
     * - Current log sequence ID
     * - Buffer for storing log entries
     *
     * @return The BlockContext containing all necessary logging state
     */
    protected abstract BlockContext getContext();

    protected abstract VFLBuffer getBuffer();
}
package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.VFL;
import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.Util;

import java.util.function.Function;
import java.util.function.Supplier;

public class Log {
    static VFL INSTANCE = new VFL() {
        @Override
        protected BlockContext getContext() {
            return ThreadContextManager.GetCurrentBlockContext();
        }

        @Override
        protected VFLBuffer getBuffer() {
            return VFLInitializer.VFLAnnotationConfig.buffer;
        }
    };

    // ================ INFO METHODS ================
    public static void Info(String message, Object... args) {
        if (!VFLInitializer.initialized) return;
        INSTANCE.info(Util.FormatMessage(message, args));
    }

    public static <R> R InfoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();
        return INSTANCE.infoFn(fn, messageSerializer);
    }

    public static <R> R InfoFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();
        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return INSTANCE.infoFn(fn, s);
    }

    public static void InfoFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }

        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        INSTANCE.infoFn(supplier, s);
    }

    // ================ WARN METHODS ================
    public static void Warn(String message, Object... args) {
        if (!VFLInitializer.initialized) return;

        INSTANCE.warn(Util.FormatMessage(message, args));
    }

    public static <R> R WarnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();

        return INSTANCE.warnFn(fn, messageSerializer);
    }

    public static <R> R WarnFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();

        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return INSTANCE.warnFn(fn, s);
    }

    public static void WarnFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }

        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        INSTANCE.warnFn(supplier, s);
    }

    // ================ ERROR METHODS ================
    public static void Error(String message, Object... args) {
        if (!VFLInitializer.initialized) return;

        INSTANCE.error(Util.FormatMessage(message, args));
    }

    public static <R> R ErrorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();

        return INSTANCE.errorFn(fn, messageSerializer);
    }

    public static <R> R ErrorFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();

        Function<R, String> s = (r) -> Util.FormatMessage(message, Util.CombineArgsWithReturn(args, r));
        return INSTANCE.errorFn(fn, s);
    }

    public static void ErrorFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }

        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> Util.FormatMessage(message, args);
        INSTANCE.errorFn(supplier, s);
    }
}

package dev.kuku.vfl.impl.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks a method as a sub block in VFL tracing.
 *
 * <p>Supports placeholders in {@link #blockName()}, {@link #startMessage()} and {@link #endMessage()}:
 * <ul>
 *   <li>{@code {0}}, {@code {1}}, ... → method arguments (0‑based index)</li>
 *   <li>{@code {r}} / {@code {return}} → return value (endMessage only)</li>
 * </ul>
 *
 * Example:
 * <pre>
 * {@code
 * @SubBlock(
 *     blockName="Process {0}",
 *     startMessage="Start {0}",
 *     endMessage="Done {0} -> {r}"
 * )
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface SubBlock {

    /** Name of the sub block. Defaults to method name if blank. */
    String blockName() default "";

    /** Message logged on entry. Blank = no start message. */
    String startMessage() default "";

    /** Message logged on exit. Blank = no end message. */
    String endMessage() default "";
}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.Util;
import dev.kuku.vfl.core.models.Block;
import lombok.extern.slf4j.Slf4j;

import java.util.Stack;

/**
 * Manager thread local context
 */
@Slf4j
class ThreadContextManager {

    static final ThreadLocal<Stack<BlockContext>> loggerCtxStack = new ThreadLocal<>();

    static void CleanThreadVariables() {
        loggerCtxStack.remove();
    }

    static void InitializeStackWithBlock(Block block) {
        loggerCtxStack.set(new Stack<>());
        loggerCtxStack.get().push(new BlockContext(block));
    }

    static void InitializeStackWithContext(BlockContext blockContext) {
        loggerCtxStack.set(new Stack<>());
        loggerCtxStack.get().push(blockContext);
    }

    static BlockContext GetCurrentBlockContext() {
        if (loggerCtxStack.get() == null || loggerCtxStack.get().isEmpty()) return null;
        return loggerCtxStack.get().peek();
    }

    static void CloseAndPopCurrentContext(String endMsg) {
        if (GetCurrentBlockContext() == null) {
            log.warn("Failed to close current context : Logger stack is empty or null. This usually happens when a method annotated with @SubBlock is invoked without parent(by using VFLStarter). Most of the time this should be okay.");
            return;
        }
        Log.INSTANCE.close(endMsg);
        BlockContext popped = loggerCtxStack.get().pop();
        log.debug("Popped current context : {}-{} for thread {}", popped.blockInfo.getBlockName(), Util.TrimId(popped.blockInfo.getId()), Util.GetThreadInfo());
    }

    static void PushBlockToThreadLogStack(Block subBlock) {
        loggerCtxStack.get().push(new BlockContext(subBlock));
    }
}
package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.Util;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.extern.slf4j.Slf4j;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bytecode.assign.Assigner;

import java.lang.reflect.Method;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static dev.kuku.vfl.core.helpers.Util.GetMethodName;

@Slf4j
public class VFLAnnotationAdvice {

    public static final VFLAnnotationAdvice instance = new VFLAnnotationAdvice();

    // Regex for {0}, {1}, etc.
    private static final Pattern PLACEHOLDER_PATTERN = Pattern.compile("\\{(\\d+)}");
    // Regex for {r} or {return} (case-insensitive)
    private static final Pattern RETURN_PLACEHOLDER_PATTERN = Pattern.compile("\\{r(?:eturn)?}", Pattern.CASE_INSENSITIVE);

    @Advice.OnMethodEnter
    public static void onEnter(@Advice.Origin Method method, @Advice.AllArguments Object[] args) {
        VFLAnnotationAdvice.instance.on_enter(method, args);
    }

    @Advice.OnMethodExit(onThrowable = Throwable.class)
    public static void onExit(@Advice.Origin Method method,
                              @Advice.AllArguments Object[] args,
                              @Advice.Return(typing = Assigner.Typing.DYNAMIC) Object returnedValue,
                              @Advice.Thrown Throwable threw) {
        VFLAnnotationAdvice.instance.on_exit(method, args, returnedValue, threw);
    }

    /* -------------------- RESOLUTION HELPERS -------------------- */

    /**
     * Get block name from annotation or use the method name.
     * Replaces {0}, {1}... placeholders with argument values.
     */
    private String resolveBlockName(Method method, Object[] args) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        String rawName = (annotation != null && isValid(annotation.blockName()))
                ? annotation.blockName().trim()
                : GetMethodName(method, args);

        return replaceArgPlaceholders(rawName, args);
    }

    /**
     * Get start message from annotation if specified.
     * Supports only argument placeholders.
     */
    private String resolveStartMessage(Method method, Object[] args) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        if (annotation != null && isValid(annotation.startMessage())) {
            String msg = annotation.startMessage().trim();
            return replaceArgPlaceholders(msg, args);
        }
        return null; // no start message
    }

    /**
     * Get end message from annotation if specified.
     * Supports argument placeholders and {r}/{return}.
     */
    private String resolveEndMessage(Method method, Object[] args, Object returnedValue) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        if (annotation != null && isValid(annotation.endMessage())) {
            String msg = annotation.endMessage().trim();
            msg = replaceArgPlaceholders(msg, args);
            msg = replaceReturnPlaceholder(msg, returnedValue);
            return msg;
        }
        return null; // no end message
    }

    private boolean isValid(String str) {
        return str != null && !str.trim().isEmpty();
    }

    /* -------------------- PLACEHOLDER REPLACERS -------------------- */

    /**
     * Replace {0}, {1}, etc. with args[i].toString() or "null".
     */
    private String replaceArgPlaceholders(String text, Object[] args) {
        if (text == null || args == null || args.length == 0) {
            return text;
        }

        Matcher matcher = PLACEHOLDER_PATTERN.matcher(text);
        StringBuilder sb = new StringBuilder();

        while (matcher.find()) {
            int index;
            try {
                index = Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                continue; // should not happen
            }

            String replacement;
            if (index >= 0 && index < args.length) {
                Object arg = args[index];
                replacement = (arg == null) ? "null" : arg.toString();
            } else {
                replacement = matcher.group(0); // leave as-is if out of range
            }

            matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));
        }

        matcher.appendTail(sb);
        return sb.toString();
    }

    /**
     * Replace {r} or {return} with returnedValue.toString() or "null".
     */
    private String replaceReturnPlaceholder(String text, Object returnedValue) {
        if (text == null) {
            return null;
        }
        String replacement = (returnedValue == null) ? "null" : returnedValue.toString();
        return RETURN_PLACEHOLDER_PATTERN.matcher(text)
                .replaceAll(Matcher.quoteReplacement(replacement));
    }

    /* -------------------- METHOD HOOKS -------------------- */

    public void on_enter(Method method, Object[] args) {
        String blockName = resolveBlockName(method, args);
        String startMessage = resolveStartMessage(method, args);

        log.debug("Entered SubBlock: {}", blockName);

        BlockContext parentBlockContext = ThreadContextManager.GetCurrentBlockContext();
        if (parentBlockContext == null) {
            log.warn("Could not create block for @SubBlock-{}: no parent block", blockName);
            return;
        }

        log.debug("Creating sub-block '{}' from parent '{}-{}'.",
                blockName,
                parentBlockContext.blockInfo.getBlockName(),
                Util.TrimId(parentBlockContext.blockInfo.getId()));

        Block subBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                blockName,
                parentBlockContext.blockInfo.getId(),
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        // Pass start message to log
        SubBlockStartLog subBlockStartLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                parentBlockContext.blockInfo.getId(),
                parentBlockContext.currentLogId,
                startMessage,
                subBlock.getId(),
                LogTypeBlockStartEnum.SUB_BLOCK_START_PRIMARY,
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        Objects.requireNonNull(ThreadContextManager.GetCurrentBlockContext()).currentLogId = subBlockStartLog.getId();
        ThreadContextManager.PushBlockToThreadLogStack(subBlock);
    }

    public void on_exit(Method method, Object[] args, Object returnedValue, Throwable threw) {
        String blockName = resolveBlockName(method, args);

        if (threw != null) {
            Log.Error("Exception in SubBlock '{}': {} - {}",
                    blockName,
                    threw.getClass().getName(),
                    threw.getMessage());
        }

        String endMsg = resolveEndMessage(method, args, returnedValue);
        ThreadContextManager.CloseAndPopCurrentContext(endMsg);
    }
}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import lombok.RequiredArgsConstructor;

/**
 * Configuration for Initializing VFL.
 *
 */
@RequiredArgsConstructor
public class VFLAnnotationConfig {
    /// If true, will completely skip instrumentation and custom VFL code will not be injected on annotated methods. Use this to quickly disable VFL globally. Logging using {@link Log} will not work either
    public final boolean disabled;
    public final VFLBuffer buffer;
}

package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.Util;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.extern.slf4j.Slf4j;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.Supplier;

/**
 * Completable future wrappers for Async operations within {@link SubBlock} methods. <br>
 * IMPORTANT: Needs to be used within a block context. Calling it outside a block makes no sense as it needs to map the sub block start to the caller's block
 */
@Slf4j
public class VFLFutures {
    private static <R> Supplier<R> wrapSupplier(Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier;
        }

        BlockContext parentContext = ThreadContextManager.GetCurrentBlockContext();
        String blockName = "Lambda_JOIN block : " + Util.GetThreadInfo() + "-" + Util.TrimId(UUID.randomUUID().toString());
        //Called outside a block skip logging
        if (parentContext == null) {
            log.error("No parent context in thread {}. Supplier will be run as a normal Completable future.", Util.GetThreadInfo());
            return supplier;
        }
        var lambdaSubBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(blockName, parentContext.blockInfo.getId(), VFLInitializer.VFLAnnotationConfig.buffer);
        VFLFlowHelper.CreateLogAndPush2Buffer(parentContext.blockInfo.getId(), parentContext.currentLogId, null, lambdaSubBlock.getId(), LogTypeBlockStartEnum.SUB_BLOCK_START_SECONDARY_JOIN, VFLInitializer.VFLAnnotationConfig.buffer);

        return () -> {
            try {
                ThreadContextManager.InitializeStackWithBlock(lambdaSubBlock);
                return supplier.get();
            } finally {
                ThreadContextManager.CloseAndPopCurrentContext(null);
                //Not necessary but safety precaution
                ThreadContextManager.CleanThreadVariables();
            }
        };
    }

    private static Runnable wrapRunnable(Runnable runnable) {
        if (VFLInitializer.isDisabled()) {
            return runnable;
        }

        BlockContext parentContext = ThreadContextManager.GetCurrentBlockContext();
        String blockName = "Lambda_NO_JOIN block : " + Util.GetThreadInfo() + "-" + Util.TrimId(UUID.randomUUID().toString());
        if (parentContext == null) {
            log.error("No parent context in thread {}. Runnable will be run as a normal Completable future.", Util.GetThreadInfo());
            return runnable;
        }
        var lambdaSubBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(blockName, parentContext.blockInfo.getId(), VFLInitializer.VFLAnnotationConfig.buffer);
        VFLFlowHelper.CreateLogAndPush2Buffer(parentContext.blockInfo.getId(), parentContext.currentLogId, null, lambdaSubBlock.getId(), LogTypeBlockStartEnum.SUB_BLOCK_START_SECONDARY_NO_JOIN, VFLInitializer.VFLAnnotationConfig.buffer);
        return () -> {
            try {
                ThreadContextManager.InitializeStackWithBlock(lambdaSubBlock);
                runnable.run();
            } finally {
                ThreadContextManager.CloseAndPopCurrentContext(null);
                //Not necessary but safety precaution
                ThreadContextManager.CleanThreadVariables();
            }
        };
    }

    // ================ PUBLIC API ================

    /**
     * invokes the supplier with the passed executor. Creates a new sub block start of type {@link LogTypeBlockStartEnum#SUB_BLOCK_START_SECONDARY_JOIN}.
     */
    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier, Executor executor) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier), executor);
    }

    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier));
    }

    /**
     * invokes the supplier with the passed executor. Creates a new sub block start of type {@link LogTypeBlockStartEnum#SUB_BLOCK_START_SECONDARY_NO_JOIN}.
     */
    public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
        return CompletableFuture.runAsync(wrapRunnable(runnable), executor);
    }

    public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return CompletableFuture.runAsync(wrapRunnable(runnable));
    }


}

package dev.kuku.vfl.impl.annotation;

import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.agent.builder.AgentBuilder;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.matcher.ElementMatchers;
import net.bytebuddy.utility.JavaModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.instrument.Instrumentation;

public class VFLInitializer {
    static Logger log = LoggerFactory.getLogger(VFLInitializer.class);
    static VFLAnnotationConfig VFLAnnotationConfig;
    static volatile boolean initialized = false;

    /**
     * Helper method to determine if VFL is functional or not.
     *
     * @return true if disabled else false
     */
    public static boolean isDisabled() {
        return !initialized || VFLAnnotationConfig == null || VFLAnnotationConfig.disabled != false;
    }

    /**
     * Initialize Visual Flow Logger, this will inject code on methods annotated with @SubBlock at start and end.
     * Make sure to ALWAYS do this first before the classes are loaded in JVM.
     * Annotation on static methods will not work IF it's in the same class where the VFL initializer is invoked. This is because the class and the static methods are loaded first and thus cant have custom code injected in them.
     *
     * @param config configuration
     */
    public static synchronized void initialize(VFLAnnotationConfig config) {
        if (config == null | config.disabled) {
            return;
        }
        try {
            Instrumentation inst = ByteBuddyAgent.install();
            VFLInitializer.VFLAnnotationConfig = config;

            new AgentBuilder.Default()
                    .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                    .with(new AgentBuilder.Listener() {
                        @Override
                        public void onDiscovery(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {
                            // Called when a type is discovered for transformation
                        }

                        @Override
                        public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader,
                                                     JavaModule module, boolean loaded, DynamicType dynamicType) {
                            log.debug("[VFL] Successfully transformed: {}", typeDescription.getName());
                        }

                        @Override
                        public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader,
                                              JavaModule module, boolean loaded) {
                            // Called when a type is ignored
                        }

                        @Override
                        public void onError(String typeName, ClassLoader classLoader, JavaModule module,
                                            boolean loaded, Throwable throwable) {
                            log.error("[VFL] Error transforming: {}", typeName, throwable);
                        }

                        @Override
                        public void onComplete(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {
                            // Called when transformation is complete
                        }
                    })
                    // Target classes that declare methods with @SubBlock annotation
                    .type(ElementMatchers.declaresMethod(ElementMatchers.isAnnotatedWith(SubBlock.class)))
                    .transform((builder, typeDescription, classLoader, javaModule, protectionDomain) -> {
                        log.debug("[VFL] Attempting to instrument: {}", typeDescription.getName());
                        return builder.visit(
                                Advice.to(VFLAnnotationAdvice.class)
                                        .on(ElementMatchers.isAnnotatedWith(SubBlock.class)
                                                .and(ElementMatchers.not(ElementMatchers.isAbstract())) // Exclude abstract methods
                                        )
                        );
                    })
                    .installOn(inst);

            initialized = true;
            log.info("[VFL] Instrumentation initialised successfully");
        } catch (Exception e) {
            log.error("[VFL] Initialisation failed", e);
            throw new RuntimeException(e);
        }
    }
}
package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.EventPublisherBlock;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;

import java.util.function.Supplier;

/**
 * Provides methods to start Logger for scenarios such as operation, continue from block & event listener.
 * It is required to use a starter to start logger because it needs to setup thread local variables.
 * In future, @RootBlock will be introduced as an alternative to StartRootBlock if user wants to use annotation
 */
public class VFLStarter {
    /**
     * Start a new flow
     *
     * @param blockName name of the flow
     * @param supplier  the method to run
     * @return return value of supplier
     */
    public static <R> R StartRootBlock(String blockName, Supplier<R> supplier) {
        //TODO throw exception if operation is already running i guess?
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        ThreadContextManager.CleanThreadVariables();
        Block rootBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(blockName, null, VFLInitializer.VFLAnnotationConfig.buffer);
        ThreadContextManager.InitializeStackWithBlock(rootBlock);
        R r;
        try {
            r = supplier.get();
            return r;
        } catch (Exception e) {
            Log.Error("Exception: {}-{})", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.CloseAndPopCurrentContext(null);
            //Safety clean up. Should not be required
            ThreadContextManager.CleanThreadVariables();
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    /**
     * Start logger as a sub block, use this as the starter in scenarios where you need make a third party service call and as the service being called you want to continue from existing block that was sent as payload from by caller.
     *
     * @param block
     * @param supplier
     * @param <R>
     * @return
     */
    public static <R> R StartAsBlock(Block block, Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        ThreadContextManager.CleanThreadVariables();
        ThreadContextManager.InitializeStackWithBlock(block);
        R r;
        try {
            r = supplier.get();
            return r;
        } catch (Exception e) {
            Log.Error("Exception: {}-{})", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.CloseAndPopCurrentContext(null);
            ThreadContextManager.CleanThreadVariables();
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    /**
     * Start event listener for the provided publisherBlock
     */
    public static <R> R StartEventListener(EventPublisherBlock publisherBlock, String eventListenerName, String message, Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        ThreadContextManager.CleanThreadVariables();

        Block eventListenerBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(eventListenerName, publisherBlock.block().getId(), VFLInitializer.VFLAnnotationConfig.buffer);

        VFLFlowHelper.CreateLogAndPush2Buffer(publisherBlock.block().getId(),
                null,
                message,
                eventListenerBlock.getId(),
                LogTypeBlockStartEnum.EVENT_LISTENER,
                VFLInitializer.VFLAnnotationConfig.buffer);
        ThreadContextManager.InitializeStackWithBlock(eventListenerBlock);

        R r;
        try {
            r = supplier.get();
            return r;
        } catch (Exception e) {
            Log.Error("Exception: {}-{})", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.CloseAndPopCurrentContext(null);
            ThreadContextManager.CleanThreadVariables();
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    // Runnable variants that delegate to Supplier versions
    public static void StartRootBlock(String blockName, Runnable runnable) {
        StartRootBlock(blockName, () -> {
            runnable.run();
            return null;
        });
    }

    public static void StartAsBlock(Block block, Runnable runnable) {
        StartAsBlock(block, () -> {
            runnable.run();
            return null;
        });
    }

    public static void StartEventListener(EventPublisherBlock publisherBlock, String eventListenerName, String message, Runnable runnable) {
        StartEventListener(publisherBlock, eventListenerName, message, () -> {
            runnable.run();
            return null;
        });
    }
}
package threadvfl;

import dev.kuku.vfl.core.buffer.AsyncBuffer;
import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.buffer.flushHandler.NestedJsonFlushHandler;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.impl.annotation.*;
import org.junit.jupiter.api.Test;

import java.util.concurrent.Executors;

public class AnnotationTest {
    static VFLBuffer b;

    static VFLBuffer createBuffer(String fileName) {
        VFLFlushHandler f = new NestedJsonFlushHandler("test/output/" + AnnotationTest.class.getSimpleName() + "/" + fileName + ".json");
        return new AsyncBuffer(100, 3000, 100, f, Executors.newVirtualThreadPerTaskExecutor(), Executors.newSingleThreadScheduledExecutor());
    }

    @Test
    void linear() {
        VFLInitializer.initialize(new VFLAnnotationConfig(false, createBuffer("linear")));
        new TestService().linear();
    }

    @Test
    void async() {
        VFLInitializer.initialize(new VFLAnnotationConfig(false, createBuffer("async")));
        new TestService().async();
    }

}

class TestService {
    @SubBlock(
            blockName = "block name is square {0}",
            startMessage = "squaring {0}",
            endMessage = "returned value is {r} for {0}"
    )
    private int square(int a) {
        return a * a;
    }

    @SubBlock
    private int squareAndMultiply(int a, int b) {
        int num = a * b;
        return square(num);
    }

    @SubBlock
    public void linear() {
        VFLStarter.StartRootBlock("Linear operation", () -> {
            Log.Info("SUP");
            int a = Log.InfoFn(() -> square(12), "Squaring {} = {}", 12);
            int b = squareAndMultiply(a, 2);
            Log.Info("COMPLETE");
        });
    }

    public void async() {
        VFLStarter.StartRootBlock("Async operation", () -> {
            Log.Info("Starting async test with thread pool");
            var e = Executors.newFixedThreadPool(1);
            var t = VFLFutures.runAsync(() -> {
                Log.Info("CRASH");
                square(1);
            });
            var t2 = VFLFutures.runAsync(() -> square(1), e);
            var y = VFLFutures.supplyAsync(() -> {
                Log.Info("Returning stuff");
                return square(2);
            }, e);

            t.join();
            t2.join();
            int num = y.join();
            Log.Info("COMPLETE with num {}", num);
        });
    }

}
