
package dev.kuku.vfl.impl.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marks a method as a sub block in VFL tracing.
 *
 * <p>Supports placeholders in {@link #blockName()}, {@link #startMessage()} and {@link #endMessage()}:
 * <ul>
 *   <li>{@code {0}}, {@code {1}}, ... ‚Üí method arguments (0‚Äëbased index)</li>
 *   <li>{@code {r}} / {@code {return}} ‚Üí return value (endMessage only)</li>
 * </ul>
 *
 * Example:
 * <pre>
 * {@code
 * @SubBlock(
 *     blockName="Process {0}",
 *     startMessage="Start {0}",
 *     endMessage="Done {0} -> {r}"
 * )
 * }
 * </pre>
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface SubBlock {

    /** Name of the sub block. Defaults to method name if blank. */
    String blockName() default "";

    /** Message logged on entry. Blank = no start message. */
    String startMessage() default "";

    /** Message logged on exit. Blank = no end message. */
    String endMessage() default "";
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.EventPublisherBlock;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;

import java.util.function.Supplier;

/**
 * Utility class to **start and continue VFL (Visual Flow Logger) tracing** within your application.
 *
 * <p>This is the entry point for wrapping your business logic so that it runs
 * within a properly initialised logging context.
 * It ensures thread-local variables are set up, blocks are pushed/popped
 * in sequence, and logs are flushed at the end.
 *
 * <p>Common scenarios:
 * <ul>
 *     <li><b>StartRootBlock</b> ‚Äì Begin a new trace for a root operation</li>
 *     <li><b>ContinueFromBlock</b> ‚Äì Continue an existing trace received from another service</li>
 *     <li><b>StartEventListener</b> ‚Äì Trace asynchronous work triggered by events/messages</li>
 * </ul>
 *
 * <p>**Note:** If VFL is disabled by configuration, these methods execute your logic without any tracing overhead.
 */
public class VFLStarter {

    /**
     * Start a new traceable root block for your operation.
     *
     * <p>Use this at the top of your service/method to start a fresh VFL trace.
     * All nested {@code @SubBlock} calls and logs will belong to this root trace.
     *
     * <p><b>Example:</b>
     * <pre>{@code
     * return VFLStarter.StartRootBlock("ProcessOrder", () -> {
     *     validateOrder();
     *     saveOrder();
     *     return "OrderID-123";
     * });
     * }</pre>
     *
     * @param blockName Logical name for the root block (operation name)
     * @param supplier  Code to execute within the trace context
     * @return The result from the supplied code
     */
    public static <R> R StartRootBlock(String blockName, Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        Block rootBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                blockName, null, VFLInitializer.VFLAnnotationConfig.buffer);

        ThreadContextManager.PushBlockToThreadLogStack(rootBlock);
        Log.INSTANCE.ensureBlockStarted();

        try {
            return supplier.get();
        } catch (Exception e) {
            Log.Error("Exception: {}-{})", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.PopCurrentStack(null);
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    /**
     * Continue tracing from a block received from another service/process.
     *
     * <p>Use for **distributed tracing** when your service is called by another system
     * that already has a VFL trace in progress.
     * Pass the {@link Block} object (e.g., from HTTP headers or message) so VFL
     * can maintain the parent-child relationship in logs.
     *
     * <p><b>Example:</b>
     * <pre>{@code
     * Block traceBlock = deserialize(request.getHeader("vfl-block"));
     * return VFLStarter.ContinueFromBlock(traceBlock, () -> handleRequest());
     * }</pre>
     *
     * @param continuationBlock The block object from upstream service
     * @param supplier          Your logic to execute inside the continued trace
     * @return The result from your code
     */
    public static <R> R ContinueFromBlock(Block continuationBlock, Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        ThreadContextManager.PushBlockToThreadLogStack(continuationBlock);
        Log.INSTANCE.ensureBlockStarted();

        try {
            return supplier.get();
        } catch (Exception e) {
            Log.Error("Exception in continuation block: {}-{}", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.PopCurrentStack(null);
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    /**
     * Start tracing for an event listener/message consumer.
     *
     * <p>Commonly used in async or pub/sub systems to log event handling
     * as part of the broader trace from the original publisher.
     *
     * <p><b>Example:</b>
     * <pre>{@code
     * VFLStarter.StartEventListener(publisherBlock, "OrderEventListener",
     *     "Received Order Created Event",
     *     () -> processOrderEvent()
     * );
     * }</pre>
     *
     * @param publisherBlock    The event publisher block (links listener to original trace)
     * @param eventListenerName Logical name for this event listener
     * @param message           Optional log message for the listener start
     * @param supplier          Code to execute to handle the event
     * @return The result from your code
     */
    public static <R> R StartEventListener(EventPublisherBlock publisherBlock,
                                           String eventListenerName,
                                           String message,
                                           Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier.get();
        }

        Block eventListenerBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                eventListenerName,
                publisherBlock.block().getId(),
                VFLInitializer.VFLAnnotationConfig.buffer);

        VFLFlowHelper.CreateLogAndPush2Buffer(
                publisherBlock.block().getId(),
                null,
                message,
                eventListenerBlock.getId(),
                LogTypeBlockStartEnum.EVENT_LISTENER,
                VFLInitializer.VFLAnnotationConfig.buffer);

        ThreadContextManager.PushBlockToThreadLogStack(eventListenerBlock);
        Log.INSTANCE.ensureBlockStarted();

        try {
            return supplier.get();
        } catch (Exception e) {
            Log.Error("Exception: {}-{})", e.getClass().getSimpleName(), e.getMessage());
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            ThreadContextManager.PopCurrentStack(null);
            VFLInitializer.VFLAnnotationConfig.buffer.flush();
        }
    }

    /**
     * Overloaded shorter form that starts an event listener trace without an initial message.
     */
    public static <R> R StartEventListener(EventPublisherBlock publisherBlock,
                                           String eventListenerName,
                                           Supplier<R> supplier) {
        return StartEventListener(publisherBlock, eventListenerName, null, supplier);
    }

    // üöÄ Runnable variants (no return value needed) ‚Äî these simply wrap the Supplier versions

    /** Runnable version of {@link #StartRootBlock(String, Supplier)} */
    public static void StartRootBlock(String blockName, Runnable runnable) {
        StartRootBlock(blockName, () -> {
            runnable.run();
            return null;
        });
    }

    /** Runnable version of {@link #ContinueFromBlock(Block, Supplier)} */
    public static void ContinueFromBlock(Block continuationBlock, Runnable runnable) {
        ContinueFromBlock(continuationBlock, () -> {
            runnable.run();
            return null;
        });
    }

    /** Runnable version of {@link #StartEventListener(EventPublisherBlock, String, String, Supplier)} */
    public static void StartEventListener(EventPublisherBlock publisherBlock,
                                          String eventListenerName,
                                          String message,
                                          Runnable runnable) {
        StartEventListener(publisherBlock, eventListenerName, message, () -> {
            runnable.run();
            return null;
        });
    }

    /** Runnable version of {@link #StartEventListener(EventPublisherBlock, String, Supplier)} */
    public static void StartEventListener(EventPublisherBlock publisherBlock,
                                          String eventListenerName,
                                          Runnable runnable) {
        StartEventListener(publisherBlock, eventListenerName, null, () -> {
            runnable.run();
            return null;
        });
    }
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.VFLHelper;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.extern.slf4j.Slf4j;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.Supplier;

/**
 * VFL‚Äëenabled {@link CompletableFuture} helpers for asynchronous operations.
 *
 * <p>This utility allows you to run async tasks **while preserving the current VFL trace context**.
 * It automatically creates a secondary {@code @SubBlock} for the async task so it appears in your flow logs.
 *
 * <p><b>Key points:</b>
 * <ul>
 *   <li>Must be called <b>inside</b> an active VFL block (e.g. inside a method already started by {@link VFLStarter})</li>
 *   <li>If called outside a block, the task still runs but without VFL logging (and logs a warning)</li>
 *   <li>{@link #supplyAsync} methods ‚Üí logs as <b>JOIN</b> blocks ({@link LogTypeBlockStartEnum#SUB_BLOCK_START_SECONDARY_JOIN})</li>
 *   <li>{@link #runAsync} methods ‚Üí logs as <b>NO_JOIN</b> blocks ({@link LogTypeBlockStartEnum#SUB_BLOCK_START_SECONDARY_NO_JOIN})</li>
 * </ul>
 *
 * <p><b>Example:</b>
 * <pre>{@code
 * VFLStarter.StartRootBlock("ProcessOrder", () -> {
 *     CompletableFuture<String> future =
 *         VFLFutures.supplyAsync(() -> fetchOrderDetails(orderId), executor);
 *
 *     // Other synchronous code...
 *
 *     return future.join(); // Wait for async work
 * });
 * }</pre>
 *
 * <p>Using these helpers ensures that async work performed via {@code CompletableFuture}
 * is correctly linked in the VFL trace, making async flows visible in your logs.
 */
@Slf4j
public class VFLFutures {

    // Wraps a Supplier to run inside a VFL secondary JOIN sub-block
    private static <R> Supplier<R> wrapSupplier(Supplier<R> supplier) {
        if (VFLInitializer.isDisabled()) {
            return supplier;
        }

        BlockContext parentContext = ThreadContextManager.GetCurrentBlockContext();
        if (parentContext == null) {
            log.error("No parent context in thread {}. Supplier will be run as a normal CompletableFuture.",
                    VFLHelper.GetThreadInfo());
            return supplier;
        }

        return () -> {
            try {
                String blockName = "Lambda_JOIN block : " + VFLHelper.GetThreadInfo() + "-" +
                        VFLHelper.TrimId(UUID.randomUUID().toString());
                var lambdaSubBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                        blockName,
                        parentContext.blockInfo.getId(),
                        VFLInitializer.VFLAnnotationConfig.buffer
                );
                VFLFlowHelper.CreateLogAndPush2Buffer(
                        parentContext.blockInfo.getId(),
                        parentContext.currentLogId,
                        null,
                        lambdaSubBlock.getId(),
                        LogTypeBlockStartEnum.SUB_BLOCK_START_SECONDARY_JOIN,
                        VFLInitializer.VFLAnnotationConfig.buffer
                );
                ThreadContextManager.PushBlockToThreadLogStack(lambdaSubBlock);

                return supplier.get();
            } finally {
                ThreadContextManager.PopCurrentStack(null);
            }
        };
    }

    // Wraps a Runnable to run inside a VFL secondary NO_JOIN sub-block
    private static Runnable wrapRunnable(Runnable runnable) {
        if (VFLInitializer.isDisabled()) {
            return runnable;
        }

        BlockContext parentContext = ThreadContextManager.GetCurrentBlockContext();
        if (parentContext == null) {
            log.error("No parent context in thread {}. Runnable will be run as a normal CompletableFuture.",
                    VFLHelper.GetThreadInfo());
            return runnable;
        }

        return () -> {
            try {
                String blockName = "Lambda_NO_JOIN block : " + VFLHelper.GetThreadInfo() + "-" +
                        VFLHelper.TrimId(UUID.randomUUID().toString());
                var lambdaSubBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                        blockName,
                        parentContext.blockInfo.getId(),
                        VFLInitializer.VFLAnnotationConfig.buffer
                );
                VFLFlowHelper.CreateLogAndPush2Buffer(
                        parentContext.blockInfo.getId(),
                        parentContext.currentLogId,
                        null,
                        lambdaSubBlock.getId(),
                        LogTypeBlockStartEnum.SUB_BLOCK_START_SECONDARY_NO_JOIN,
                        VFLInitializer.VFLAnnotationConfig.buffer
                );
                ThreadContextManager.PushBlockToThreadLogStack(lambdaSubBlock);

                runnable.run();
            } finally {
                ThreadContextManager.PopCurrentStack(null);
            }
        };
    }

    // ========= PUBLIC API =========

    /**
     * Runs a supplier asynchronously using the given executor, creating a
     * secondary JOIN sub-block for logging.
     */
    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier, Executor executor) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier), executor);
    }

    /**
     * Runs a supplier asynchronously (common pool), creating a
     * secondary JOIN sub-block for logging.
     */
    public static <R> CompletableFuture<R> supplyAsync(Supplier<R> supplier) {
        return CompletableFuture.supplyAsync(wrapSupplier(supplier));
    }

    /**
     * Runs a runnable asynchronously using the given executor, creating a
     * secondary NO_JOIN sub-block for logging.
     */
    public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor) {
        return CompletableFuture.runAsync(wrapRunnable(runnable), executor);
    }

    /**
     * Runs a runnable asynchronously (common pool), creating a
     * secondary NO_JOIN sub-block for logging.
     */
    public static CompletableFuture<Void> runAsync(Runnable runnable) {
        return CompletableFuture.runAsync(wrapRunnable(runnable));
    }
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import lombok.RequiredArgsConstructor;

/**
 * Configuration object for initializing Visual Flow Logger (VFL) annotation-based tracing.
 *
 * <p>This config is passed to {@link VFLInitializer#initialize(VFLAnnotationConfig)} to control
 * whether VFL is enabled and where trace data is stored.
 *
 * <p><b>Fields:</b>
 * <ul>
 *   <li>{@code disabled} ‚Äì If {@code true}, VFL is completely disabled:
 *       <ul>
 *           <li>No bytecode instrumentation will be applied to annotated methods</li>
 *           <li>{@link Log} calls will be ignored</li>
 *           <li>This can be used as a quick global "off switch" for VFL</li>
 *       </ul>
 *   </li>
 *   <li>{@code buffer} ‚Äì The {@link VFLBuffer} implementation used to store
 *       logs and block execution data before flushing.
 *       This can be an in-memory, async, or custom implementation depending on your needs.</li>
 * </ul>
 *
 * <p><b>Example:</b>
 * <pre>{@code
 * VFLBuffer buffer = new MyCustomBuffer();
 * VFLAnnotationConfig config = new VFLAnnotationConfig(false, buffer);
 * VFLInitializer.initialize(config);
 * }</pre>
 */
@RequiredArgsConstructor
public class VFLAnnotationConfig {

    /**
     * If {@code true}, disables all VFL functionality.
     * No instrumentation will be applied and {@link Log} calls will not output anything.
     */
    public final boolean disabled;

    /**
     * The buffer used for collecting and temporarily storing VFL logs and flow data.
     * Must not be {@code null} when {@code disabled} is false.
     */
    public final VFLBuffer buffer;
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.helpers.VFLHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.extern.slf4j.Slf4j;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.implementation.bytecode.assign.Assigner;

import java.lang.reflect.Method;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static dev.kuku.vfl.core.helpers.VFLHelper.GetMethodName;

/**
 * ByteBuddy advice class injected into methods annotated with {@link SubBlock}.
 *
 * <p>This is applied at load‚Äëtime by {@link VFLInitializer} using ByteBuddy
 * and is responsible for:
 * <ul>
 *   <li>Creating a new VFL sub‚Äëblock on method entry</li>
 *   <li>Logging an optional start message</li>
 *   <li>Replacing any placeholders in block names or messages with
 *       runtime values (method args / return value)</li>
 *   <li>Logging exceptions if the method throws</li>
 *   <li>Popping the block stack and logging an optional end message on exit</li>
 * </ul>
 *
 * <h3>Placeholder resolution rules</h3>
 * The following placeholders used in {@link SubBlock#blockName()},
 * {@link SubBlock#startMessage()}, and {@link SubBlock#endMessage()} are replaced
 * at runtime:
 * <ul>
 *   <li><b>{0}, {1}, ...</b> ‚Äî replaced with the string value of the Nth method argument
 *       (0‚Äëindexed). Out‚Äëof‚Äërange indices are left unchanged.
 *       Null arguments are replaced with {@code "null"}.</li>
 *   <li><b>{r}</b> or <b>{return}</b> ‚Äî replaced with the return value's string form in
 *       the <em>end message</em> only. Null replaced with {@code "null"}.
 *       Case‚Äëinsensitive.</li>
 * </ul>
 *
 * <p><b>Note:</b> This advice assumes it is only executed for methods that were
 * matched in the ByteBuddy transformation phase via
 * {@code ElementMatchers.isAnnotatedWith(SubBlock.class)}.
 */
@Slf4j
public class VFLAnnotationAdvice {

    public static final VFLAnnotationAdvice instance = new VFLAnnotationAdvice();

    // Regex for {0}, {1}, etc.
    private static final Pattern PLACEHOLDER_PATTERN = Pattern.compile("\\{(\\d+)}");
    // Regex for {r} or {return} (case-insensitive)
    private static final Pattern RETURN_PLACEHOLDER_PATTERN =
            Pattern.compile("\\{r(?:eturn)?}", Pattern.CASE_INSENSITIVE);

    /**
     * ByteBuddy entry point ‚Äî delegates to {@link #on_enter(Method, Object[])}.
     */
    @Advice.OnMethodEnter
    public static void onEnter(@Advice.Origin Method method,
                               @Advice.AllArguments Object[] args) {
        VFLAnnotationAdvice.instance.on_enter(method, args);
    }

    /**
     * ByteBuddy exit point ‚Äî delegates to {@link #on_exit(Method, Object[], Object, Throwable)}.
     * Runs for both normal return and exceptional exit.
     */
    @Advice.OnMethodExit(onThrowable = Throwable.class)
    public static void onExit(@Advice.Origin Method method,
                              @Advice.AllArguments Object[] args,
                              @Advice.Return(typing = Assigner.Typing.DYNAMIC) Object returnedValue,
                              @Advice.Thrown Throwable threw) {
        VFLAnnotationAdvice.instance.on_exit(method, args, returnedValue, threw);
    }

    /* -------------------- Runtime helper methods -------------------- */

    private boolean isValid(String str) {
        return str != null && !str.trim().isEmpty();
    }

    /**
     * Replace {0}, {1}, ... argument placeholders with actual argument string values.
     * Null arguments become "null". Invalid indexes are left unchanged.
     */
    private String replaceArgPlaceholders(String text, Object[] args) {
        if (text == null || args == null || args.length == 0) {
            return text;
        }
        Matcher matcher = PLACEHOLDER_PATTERN.matcher(text);
        StringBuilder sb = new StringBuilder();
        while (matcher.find()) {
            int index;
            try {
                index = Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                continue; // Should not happen for matched groups
            }
            String replacement;
            if (index >= 0 && index < args.length) {
                Object arg = args[index];
                replacement = (arg == null) ? "null" : arg.toString();
            } else {
                replacement = matcher.group(0); // leave as-is
            }
            matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    /**
     * Replace {r} / {return} placeholders with return value string.
     * Only applied to endMessage. Null becomes "null".
     */
    private String replaceReturnPlaceholder(String text, Object returnedValue) {
        if (text == null) {
            return null;
        }
        String replacement = (returnedValue == null) ? "null" : returnedValue.toString();
        return RETURN_PLACEHOLDER_PATTERN.matcher(text)
                .replaceAll(Matcher.quoteReplacement(replacement));
    }

    /* -------------------- Actual enter/exit logic -------------------- */

    /**
     * Called at the start of a {@code @SubBlock} method.
     * Resolves block name, start message (with placeholders replaced),
     * creates and pushes a sub‚Äëblock, and issues a start log.
     * Skips if there is no active parent VFL block in context.
     */
    public void on_enter(Method method, Object[] args) {
        String blockName = VFLHelper.ResolveBlockName(method, args);
        String startMessage = VFLHelper.ResolveStartMessage(method, args);

        log.debug("Entered SubBlock: {}", blockName);

        BlockContext parentBlockContext = ThreadContextManager.GetCurrentBlockContext();
        if (parentBlockContext == null) {
            log.warn("Could not create block for @SubBlock-{}: no parent block", blockName);
            return;
        }

        log.debug("Creating sub-block '{}' from parent '{}-{}'.",
                blockName,
                parentBlockContext.blockInfo.getBlockName(),
                VFLHelper.TrimId(parentBlockContext.blockInfo.getId()));

        Block subBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                blockName,
                parentBlockContext.blockInfo.getId(),
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        SubBlockStartLog subBlockStartLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                parentBlockContext.blockInfo.getId(),
                parentBlockContext.currentLogId,
                startMessage,
                subBlock.getId(),
                LogTypeBlockStartEnum.SUB_BLOCK_START_PRIMARY,
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        Objects.requireNonNull(ThreadContextManager.GetCurrentBlockContext()).currentLogId = subBlockStartLog.getId();
        ThreadContextManager.PushBlockToThreadLogStack(subBlock);
        Log.INSTANCE.ensureBlockStarted();
    }

    /**
     * Called on method exit (normal or exceptional).
     * <ul>
     *   <li>If an exception was thrown, logs it immediately at error level</li>
     *   <li>Resolves the end message (with arguments & return value placeholders)</li>
     *   <li>Pops the current block off the thread local stack</li>
     * </ul>
     */
    public void on_exit(Method method, Object[] args, Object returnedValue, Throwable threw) {
        String blockName = VFLHelper.ResolveBlockName(method, args);

        if (threw != null) {
            Log.Error("Exception in SubBlock '{}': {} - {}",
                    blockName,
                    threw.getClass().getName(),
                    threw.getMessage());
        }

        String endMsg = VFLHelper.ResolveEndMessage(method, args, returnedValue);
        ThreadContextManager.PopCurrentStack(endMsg);
    }
}



package dev.kuku.vfl.impl.annotation;

import net.bytebuddy.agent.ByteBuddyAgent;
import net.bytebuddy.agent.builder.AgentBuilder;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.matcher.ElementMatchers;
import net.bytebuddy.utility.JavaModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.instrument.Instrumentation;

/**
 * Visual Flow Logger (VFL) initializer for annotation-based tracing.
 *
 * <p>This class sets up runtime bytecode instrumentation to automatically inject
 * custom VFL tracing logic into methods annotated with {@link SubBlock}.
 * It uses the ByteBuddy Java agent to modify method bytecode at load time.
 *
 * <p><b>Important notes:</b>
 * <ul>
 *   <li>Call {@link #initialize(VFLAnnotationConfig)} <b>very early</b> ‚Äî ideally before any application
 *       classes containing {@code @SubBlock} methods are loaded ‚Äî to ensure those methods get instrumented.</li>
 *   <li>Static methods in the same class that calls this initializer cannot be instrumented
 *       because their declaring class will already be loaded.</li>
 *   <li>If {@code disabled} is true, this initializer exits immediately without setting up anything.</li>
 * </ul>
 */
public class VFLInitializer {

    static Logger log = LoggerFactory.getLogger(VFLInitializer.class);
    static VFLAnnotationConfig VFLAnnotationConfig;
    static volatile boolean initialized = false;

    /**
     * Checks if VFL annotation-based tracing is currently disabled.
     *
     * @return {@code true} if disabled or not initialized, otherwise {@code false}.
     */
    public static boolean isDisabled() {
        return !initialized || VFLAnnotationConfig == null || VFLAnnotationConfig.disabled;
    }

    /**
     * Initializes VFL annotation-based instrumentation.
     *
     * <p>This will:
     * <ul>
     *   <li>Install the ByteBuddy agent into the running JVM</li>
     *   <li>Store the given {@link VFLAnnotationConfig}</li>
     *   <li>Instrument all non-abstract methods annotated with {@link SubBlock} so that VFL tracing code
     *       is automatically executed at their start and end.</li>
     * </ul>
     *
     * <p><b>Parameters:</b>
     * <ul>
     *     <li><b>{@code disabled}</b> ‚Äî if true, skips all instrumentation and disables tracing/logging globally.</li>
     *     <li><b>{@code buffer}</b> ‚Äî the {@link dev.kuku.vfl.core.buffer.VFLBuffer} where logs are stored before being flushed.</li>
     * </ul>
     *
     * <p><b>Example:</b>
     * <pre>{@code
     * VFLAnnotationConfig config =
     *      new VFLAnnotationConfig(false, new MyCustomBuffer());
     *
     * VFLInitializer.initialize(config);
     * }</pre>
     *
     * <p><b>Caution:</b>
     * This must be called before annotated classes are loaded.
     * Once a class is loaded, its bytecode cannot be modified unless retransformation is explicitly allowed.
     *
     * @param config VFL annotation configuration with buffer and enable/disable flag
     */
    public static synchronized void initialize(VFLAnnotationConfig config) {
        if (config == null || config.disabled) {
            return; // Do nothing if config is missing or disabled
        }
        try {
            // Attach ByteBuddy agent to JVM
            Instrumentation inst = ByteBuddyAgent.install();
            VFLInitializer.VFLAnnotationConfig = config;

            // Configure ByteBuddy to transform classes with @SubBlock annotated methods
            new AgentBuilder.Default()
                    .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
                    .with(new AgentBuilder.Listener() {
                        @Override
                        public void onDiscovery(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {}

                        @Override
                        public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader,
                                                     JavaModule module, boolean loaded, DynamicType dynamicType) {
                            log.debug("[VFL] Successfully transformed: {}", typeDescription.getName());
                        }

                        @Override
                        public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader,
                                              JavaModule module, boolean loaded) {}

                        @Override
                        public void onError(String typeName, ClassLoader classLoader, JavaModule module,
                                            boolean loaded, Throwable throwable) {
                            log.error("[VFL] Error transforming: {}", typeName, throwable);
                        }

                        @Override
                        public void onComplete(String typeName, ClassLoader classLoader,
                                               JavaModule module, boolean loaded) {}
                    })
                    // Match classes that declare any method annotated with @SubBlock
                    .type(ElementMatchers.declaresMethod(ElementMatchers.isAnnotatedWith(SubBlock.class)))
                    // Inject advice into those annotated methods, excluding abstract ones
                    .transform((builder, typeDescription, classLoader, javaModule, protectionDomain) -> {
                        log.debug("[VFL] Attempting to instrument: {}", typeDescription.getName());
                        return builder.visit(
                                Advice.to(VFLAnnotationAdvice.class)
                                        .on(ElementMatchers.isAnnotatedWith(SubBlock.class)
                                                .and(ElementMatchers.not(ElementMatchers.isAbstract())))
                        );
                    })
                    .installOn(inst);

            initialized = true;
            log.info("[VFL] Instrumentation initialised successfully");
        } catch (Exception e) {
            log.error("[VFL] Initialisation failed", e);
            throw new RuntimeException(e);
        }
    }
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.VFL;
import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.dtos.EventPublisherBlock;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.helpers.VFLHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Main logging API for Visual Flow Logger (VFL) when using the annotation-based approach.
 *
 * <p>Provides static convenience methods for logging at different levels ({@code Info}, {@code Warn}, {@code Error}),
 * publishing events, and creating continuation blocks for distributed tracing.
 *
 * <p>All methods automatically link log entries to the current VFL block context
 * (root, sub-block, or event listener) so they appear as part of your execution flow.
 * If VFL is not initialized or disabled, these methods are no‚Äëops (or just execute the function without logging).
 *
 * <h2>Key use cases:</h2>
 * <ul>
 *   <li>Log a simple message linked to the current trace</li>
 *   <li>Wrap the execution of a lambda and automatically log before/after with messages containing results</li>
 *   <li>Publish an {@link EventPublisherBlock} to link async event processing to the originating trace</li>
 *   <li>Create a ‚Äúcontinuation block‚Äù for cross-service or async messaging tracing</li>
 * </ul>
 *
 * <h2>Message formatting:</h2>
 * <p>Message templates support placeholders like {@code {0}}, {@code {1}}, etc. for method arguments,
 * and some methods also allow embedding the return value using {@code {r}} or {@code {return}}.
 */
public class Log {

    // Core VFL instance tied to current thread context and buffer
    static VFL INSTANCE = new VFL() {
        @Override
        protected BlockContext getContext() {
            return ThreadContextManager.GetCurrentBlockContext();
        }

        @Override
        protected VFLBuffer getBuffer() {
            return VFLInitializer.VFLAnnotationConfig.buffer;
        }
    };

    // -------------------- INFO --------------------

    /**
     * Log an informational message in the current VFL block.
     *
     * @param message message template
     * @param args    arguments for formatting
     */
    public static void Info(String message, Object... args) {
        if (!VFLInitializer.initialized) return;
        INSTANCE.info(VFLHelper.FormatMessage(message, args));
    }

    /**
     * Execute a supplier, then log an info message based on its return value.
     *
     * @param fn                supplier to execute
     * @param messageSerializer function to turn result into a log message
     * @param <R>               supplier return type
     */
    public static <R> R InfoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();
        return INSTANCE.infoFn(fn, messageSerializer);
    }

    /**
     * Execute a supplier and log an info message with a template that can include the result.
     *
     * @param fn      supplier to run
     * @param message message template (use {r} to insert the return value)
     * @param args    args for formatting
     */
    public static <R> R InfoFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();
        Function<R, String> s = (r) -> VFLHelper.FormatMessage(message, VFLHelper.CombineArgsWithReturn(args, r));
        return INSTANCE.infoFn(fn, s);
    }

    /**
     * Run a {@link Runnable} and log an info message after completion.
     */
    public static void InfoFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> VFLHelper.FormatMessage(message, args);
        INSTANCE.infoFn(supplier, s);
    }

    // -------------------- WARN --------------------

    /**
     * Same as {@link #Info(String, Object...)} but logs at WARN level.
     */
    public static void Warn(String message, Object... args) {
        if (!VFLInitializer.initialized) return;
        INSTANCE.warn(VFLHelper.FormatMessage(message, args));
    }

    public static <R> R WarnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();
        return INSTANCE.warnFn(fn, messageSerializer);
    }

    public static <R> R WarnFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();
        Function<R, String> s = (r) -> VFLHelper.FormatMessage(message, VFLHelper.CombineArgsWithReturn(args, r));
        return INSTANCE.warnFn(fn, s);
    }

    public static void WarnFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> VFLHelper.FormatMessage(message, args);
        INSTANCE.warnFn(supplier, s);
    }

    // -------------------- ERROR --------------------

    /**
     * Same as {@link #Info(String, Object...)} but logs at ERROR level.
     */
    public static void Error(String message, Object... args) {
        if (!VFLInitializer.initialized) return;
        INSTANCE.error(VFLHelper.FormatMessage(message, args));
    }

    public static <R> R ErrorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        if (!VFLInitializer.initialized) return fn.get();
        return INSTANCE.errorFn(fn, messageSerializer);
    }

    public static <R> R ErrorFn(Supplier<R> fn, String message, Object... args) {
        if (!VFLInitializer.initialized) return fn.get();
        Function<R, String> s = (r) -> VFLHelper.FormatMessage(message, VFLHelper.CombineArgsWithReturn(args, r));
        return INSTANCE.errorFn(fn, s);
    }

    public static void ErrorFn(Runnable runnable, String message, Object... args) {
        if (!VFLInitializer.initialized) {
            runnable.run();
            return;
        }
        Supplier<Void> supplier = () -> {
            runnable.run();
            return null;
        };
        Function<Void, String> s = (r) -> VFLHelper.FormatMessage(message, args);
        INSTANCE.errorFn(supplier, s);
    }

    // -------------------- EVENT PUBLISHING --------------------

    /**
     * Create and log an {@link EventPublisherBlock} which links an event to the current trace.
     * Use when producing messages or events that will be consumed later.
     */
    public static EventPublisherBlock Publish(String publisherName, String message) {
        if (!VFLInitializer.initialized) return null;
        return INSTANCE.publish(publisherName, message);
    }

    public static EventPublisherBlock Publish(String publisherName, String message, Object... args) {
        if (!VFLInitializer.initialized) return null;
        return INSTANCE.publish(publisherName, VFLHelper.FormatMessage(message, args));
    }

    /**
     * Overload for when you have no start message.
     */
    public static EventPublisherBlock Publish(String publisherName) {
        if (!VFLInitializer.initialized) return null;
        return INSTANCE.publish(publisherName, "");
    }

    // -------------------- CONTINUATION BLOCKS --------------------

    /**
     * Create a detached continuation block for cross-service or async tracing.
     *
     * <p>The returned {@link Block} is <b>not</b> pushed to the current thread ‚Äî
     * it‚Äôs meant to be sent to another external service, which can then use
     * {@link VFLStarter#ContinueFromBlock(Block, Supplier)} to continue the trace.
     *
     * <p><b>Typical uses:</b> passing trace info in HTTP headers, message payloads, or background jobs.
     */
    public static <R> R CreateContinuationBlock(String blockName, String startMessage, Function<Block, R> fn) {
        if (!VFLInitializer.initialized) return fn.apply(null);

        BlockContext currentContext = ThreadContextManager.GetCurrentBlockContext();
        if (currentContext == null) {
            throw new IllegalStateException(
                    "Cannot create continuation block: no active VFL context. " +
                            "Ensure you're inside a VFL root block or sub-block."
            );
        }

        Block detachedBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                blockName,
                currentContext.blockInfo.getId(),
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        SubBlockStartLog subBlockStartLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                currentContext.blockInfo.getId(),
                currentContext.currentLogId,
                startMessage,
                detachedBlock.getId(),
                LogTypeBlockStartEnum.SUB_BLOCK_CONTINUE,
                VFLInitializer.VFLAnnotationConfig.buffer
        );

        currentContext.currentLogId = subBlockStartLog.getId();

        try {
            return fn.apply(detachedBlock);
        } catch (Exception e) {
            Log.Error("Exception in continuation block '{}': {} - {}",
                    blockName, e.getClass().getSimpleName(), e.getMessage());
            throw e;
        } finally {
            VFLFlowHelper.CreateLogAndPush2Buffer(
                    subBlockStartLog.getBlockId(),
                    subBlockStartLog.getId(), null,
                    null, LogTypeBlockStartEnum.SUB_BLOCK_CONTINUE_COMPLETE, VFLInitializer.VFLAnnotationConfig.buffer
            );
        }
    }

    /**
     * Overload with formatted start message.
     */
    public static <R> R CreateContinuationBlock(String blockName, String startMessage, Object[] args, Function<Block, R> fn) {
        return CreateContinuationBlock(blockName, VFLHelper.FormatMessage(startMessage, args), fn);
    }

    /**
     * Overload with no start message.
     */
    public static <R> R CreateContinuationBlock(String blockName, Function<Block, R> fn) {
        return CreateContinuationBlock(blockName, "", fn);
    }

    /**
     * Void version accepting a {@link Consumer}.
     */
    public static void CreateContinuationBlock(String blockName, String startMessage, Consumer<Block> consumer) {
        CreateContinuationBlock(blockName, startMessage, block -> {
            consumer.accept(block);
            return null;
        });
    }

    /**
     * Void version with formatted message.
     */
    public static void CreateContinuationBlock(String blockName, String startMessage, Object[] args, Consumer<Block> consumer) {
        CreateContinuationBlock(blockName, VFLHelper.FormatMessage(startMessage, args), consumer);
    }

    /**
     * Void version with no message.
     */
    public static void CreateContinuationBlock(String blockName, Consumer<Block> consumer) {
        CreateContinuationBlock(blockName, "", consumer);
    }
}



package dev.kuku.vfl.impl.annotation;

import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.helpers.VFLHelper;
import dev.kuku.vfl.core.models.Block;
import lombok.extern.slf4j.Slf4j;

import java.util.Stack;

/**
 * Thread-local stack manager for VFL {@link BlockContext}s.
 *
 * <p>This class maintains the execution context for the current thread‚Äôs active VFL blocks.
 * Each thread has its own stack of {@link BlockContext} objects, representing
 * the nested block hierarchy during the trace.
 *
 * <p><b>Responsibilities:</b>
 * <ul>
 *   <li>Push new block contexts when entering a traced block</li>
 *   <li>Pop and close contexts when leaving a traced block</li>
 *   <li>Clear the thread-local stack entirely when it becomes empty</li>
 *   <li>Provide quick access to the current (top) block context</li>
 * </ul>
 *
 * <p><b>Lifecycle Notes:</b>
 * <ul>
 *   <li>The stack grows as methods annotated with {@code @SubBlock} (or created via {@link VFLStarter}) are entered.</li>
 *   <li>Each push <b>must</b> be matched with a pop to avoid memory leaks and incorrect trace linking.</li>
 *   <li>If a pop is attempted without any active block, a warning is logged because it usually means
 *       a traced method was executed without a proper parent block context.</li>
 * </ul>
 *
 * <p>This is an <b>internal utility</b> ‚Äî not designed for direct use by end‚Äëusers of the VFL library.
 */
@Slf4j
class ThreadContextManager {

    /** Per-thread stack holding nested block execution contexts */
    static final ThreadLocal<Stack<BlockContext>> loggerCtxStack = new ThreadLocal<>();

    /**
     * Get the current (top) block context for this thread.
     *
     * @return current {@link BlockContext} at the top of the stack, or {@code null} if none exists.
     */
    static BlockContext GetCurrentBlockContext() {
        if (loggerCtxStack.get() == null || loggerCtxStack.get().isEmpty()) return null;
        return loggerCtxStack.get().peek();
    }

    /**
     * Pop and close the current block context for this thread.
     *
     * <p>Performs the following:
     * <ol>
     *   <li>Checks if there is an active context; logs a warning if not found</li>
     *   <li>Closes the current block via {@link Log#close(String)}</li>
     *   <li>Pops the context from the stack</li>
     *   <li>If the stack becomes empty, removes the ThreadLocal entirely</li>
     * </ol>
     *
     * @param endMsg optional message passed to {@link Log#close(String)}
     */
    static void PopCurrentStack(String endMsg) {
        if (GetCurrentBlockContext() == null) {
            log.warn("Failed to close current context : Logger stack is empty or null. "
                    + "This usually happens when a method annotated with @SubBlock is invoked "
                    + "without a parent (via VFLStarter). Usually this can be ignored.");
            return;
        }
        Log.INSTANCE.close(endMsg);
        BlockContext popped = loggerCtxStack.get().pop();
        log.debug("Popped current context : {}-{} for thread {}",
                popped.blockInfo.getBlockName(),
                VFLHelper.TrimId(popped.blockInfo.getId()),
                VFLHelper.GetThreadInfo());

        if (loggerCtxStack.get().isEmpty()) {
            log.debug("LoggerCtxStack is empty for thread {}, Removing thread variable",
                    VFLHelper.GetThreadInfo());
            loggerCtxStack.remove();
        }
    }

    /**
     * Push a new {@link Block} onto the current thread's context stack.
     *
     * <p>Wraps the block inside a new {@link BlockContext} before pushing.
     * If the stack is not yet created for this thread, it initializes it.
     *
     * @param subBlock the new block to push as the current context
     */
    static void PushBlockToThreadLogStack(Block subBlock) {
        if (GetCurrentBlockContext() == null) {
            loggerCtxStack.set(new Stack<>());
        }
        loggerCtxStack.get().push(new BlockContext(subBlock));
    }
}



package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeBlockStartEnum {
    SUB_BLOCK_START_PRIMARY("SUB_BLOCK_START_PRIMARY"),
    SUB_BLOCK_START_SECONDARY_NO_JOIN("SUB_BLOCK_START_SECONDARY_NO_JOIN"),
    PUBLISH_EVENT("PUBLISH_EVENT"),
    SUB_BLOCK_START_SECONDARY_JOIN("SUB_BLOCK_START_SECONDARY_JOIN"),
    SUB_BLOCK_CONTINUE("SUB_BLOCK_CONTINUE"),
    SUB_BLOCK_CONTINUE_COMPLETE("SUB_BLOCK_CONTINUE_COMPLETE"),
    EVENT_LISTENER("EVENT_LISTENER");

    private final String displayName;

    // Constructor to set the display name
    LogTypeBlockStartEnum(String displayName) {
        this.displayName = displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}


package dev.kuku.vfl.core.models.logs.enums;

public enum LogTypeEnum {
    MESSAGE("MESSAGE"),
    WARN("WARN"),
    ERROR("ERROR");

    private final String DisplayName;

    LogTypeEnum(String displayName) {
        DisplayName = displayName;
    }
}



package dev.kuku.vfl.core.models.logs;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;

public class LogType {
    public final String value;

    public LogType(LogTypeEnum logType) {
        this.value = logType.toString();
    }

    public LogType(LogTypeBlockStartEnum logType) {
        this.value = logType.toString();
    }

    // Private constructor for Jackson deserialization
    private LogType(String value) {
        this.value = value;
    }

    @JsonValue  // This tells Jackson to serialize this object as just the string value
    @Override
    public String toString() {
        return this.value;
    }

    @JsonCreator  // This tells Jackson how to create the object from a string
    public static LogType fromString(String value) {
        return new LogType(value);
    }
}


package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Primitive Log that is simple in nature.
 */
@Getter
@RequiredArgsConstructor
public class Log {
    private final String id;
    private final String blockId;
    private final String parentLogId;
    private final LogType logType;
    private final String message;
    private final long timestamp;

    public Log(String id, String blockId, String parentLogId, LogTypeEnum logType, String message, long timestamp) {

        this.id = id;
        this.blockId = blockId;
        this.parentLogId = parentLogId;
        this.logType = new LogType(logType);
        this.message = message;
        this.timestamp = timestamp;
    }
}


package dev.kuku.vfl.core.models.logs;

import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import lombok.Getter;

import java.time.Instant;

/**
 * Sub block start log following block's flow chain.
 */
@Getter
public class SubBlockStartLog extends Log {
    //The block that is being started
    private final String referencedBlockId;

    public SubBlockStartLog(String id, String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType) {
        super(id, blockId, parentLogId, new LogType(logType), startMessage, Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }

    public SubBlockStartLog(Log log, String referencedBlockId, LogTypeBlockStartEnum logTypeBlockStartEnum) {
        super(log.getId(), log.getBlockId(), log.getParentLogId(), new LogType(logTypeBlockStartEnum), log.getMessage(), Instant.now().toEpochMilli());
        this.referencedBlockId = referencedBlockId;
    }
}


package dev.kuku.vfl.core.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class Block {
    private String id;
    private String parentBlockId;
    private String blockName;
}


package dev.kuku.vfl.core;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.dtos.BlockContext;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.dtos.EventPublisherBlock;
import dev.kuku.vfl.core.helpers.VFLFlowHelper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * Base class for all Visual Flow Logger (VFL) implementations.
 *
 * <p>This abstract class provides the core logging, event publishing,
 * and block lifecycle handling for VFL traces. It is designed to be
 * subclassed by concrete logging entry points, such as
 * {@code Log} in the annotation-based VFL implementation.</p>
 *
 * <h2>Key Behaviors</h2>
 * <ul>
 *   <li>Ensures a block is "started" before writing logs to it</li>
 *   <li>Supports logging at INFO ({@link #info}), WARN ({@link #warn}), and ERROR ({@link #error}) levels</li>
 *   <li>Allows functional-style logging with {@code *Fn} variants that run a lambda and log its result</li>
 *   <li>Enables event publishing via {@link #publish(String, String)} which links producer and consumer traces</li>
 * </ul>
 *
 * <h2>Framework Notes</h2>
 * <ul>
 *   <li>Log entries are always scoped to the current {@link BlockContext} returned by {@link #getContext()}</li>
 *   <li>{@link #getBuffer()} determines where logs are temporarily staged (in-memory, async buffer, etc.)</li>
 *   <li>Public logging methods are final to maintain consistency; intended extensions are via context/buffer provision</li>
 * </ul>
 *
 * <h2>Usage Example</h2>
 * A subclass provides the context and buffer:
 * <pre>{@code
 * static VFL INSTANCE = new VFL() {
 *     protected BlockContext getContext() {
 *         return ThreadContextManager.GetCurrentBlockContext();
 *     }
 *     protected VFLBuffer getBuffer() {
 *         return VFLInitializer.VFLAnnotationConfig.buffer;
 *     }
 * };
 *
 * // In user code inside a VFLStarter block:
 * Log.Info("Processing item {}", itemId);
 * }</pre>
 */
@Slf4j
public abstract class VFL {

    /**
     * Ensures the current block has been marked as started.
     * <p>If not yet started, pushes a "start" entry into the buffer with the current timestamp.
     * This must be done before any logs for the block are written.</p>
     */
    public final void ensureBlockStarted() {
        final BlockContext context = getContext();
        if (context.blockStarted.compareAndSet(false, true)) {
            final long startTimestamp = Instant.now().toEpochMilli();
            getBuffer().pushLogStartToBuffer(context.blockInfo.getId(), startTimestamp);
        }
    }

    /**
     * Closes the current block, pushing an "end" entry into the buffer
     * with an optional final message and timestamp.
     *
     * @param endMessage optional message describing why or how the block completed
     */
    public void close(String endMessage) {
        ensureBlockStarted();
        final BlockContext context = getContext();
        final long endTimestamp = Instant.now().toEpochMilli();
        getBuffer().pushLogEndToBuffer(context.blockInfo.getId(), new BlockEndData(endTimestamp, endMessage));
    }

    /**
     * Core logging method that ensures the block is started,
     * creates a log entry with the given type and message,
     * and updates the current log ID in context.
     */
    private void logInternal(LogTypeEnum type, String message) {
        ensureBlockStarted();
        final BlockContext context = getContext();
        final var createdLog = VFLFlowHelper.CreateLogAndPush2Buffer(
                context.blockInfo.getId(),
                context.currentLogId,
                type,
                message,
                getBuffer()
        );
        context.currentLogId = createdLog.getId();
    }

    /**
     * Executes a function, then serializes and logs the result.
     * This is useful when the log message depends on the return value.
     */
    private <R> R logFnInternal(LogTypeEnum type, Supplier<R> fn, Function<R, String> messageSerializer) {
        final R result = fn.get();
        final String message = messageSerializer.apply(result);
        logInternal(type, message);
        return result;
    }

    // ========== PUBLIC LOGGING METHODS ==========

    /**
     * Log a message at INFO/MESSAGE level.
     */
    public final void info(String message) {
        logInternal(LogTypeEnum.MESSAGE, message);
    }

    /**
     * Executes a supplier and logs its result at MESSAGE level.
     * Allows result-based dynamic message generation.
     */
    public final <R> R infoFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.MESSAGE, fn, messageSerializer);
    }

    /**
     * Log a warning message at WARN level.
     */
    public final void warn(String message) {
        logInternal(LogTypeEnum.WARN, message);
    }

    /**
     * Executes a supplier and logs its result at WARN level.
     */
    public final <R> R warnFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.WARN, fn, messageSerializer);
    }

    /**
     * Executes a supplier and logs its result at ERROR level.
     */
    public final <R> R errorFn(Supplier<R> fn, Function<R, String> messageSerializer) {
        return logFnInternal(LogTypeEnum.ERROR, fn, messageSerializer);
    }

    /**
     * Log an error message at ERROR level.
     */
    public final void error(String message) {
        logInternal(LogTypeEnum.ERROR, message);
    }

    // ========== EVENT PUBLISHING ==========

    /**
     * Creates and logs an {@link EventPublisherBlock} linked to the current block.
     * <p>Used to track outgoing events/messages so they can be connected
     * to downstream processing in event listeners.</p>
     *
     * @param publisherName name of the publisher/event source
     * @param message       optional message describing the event
     * @return the created {@link EventPublisherBlock} representing this publish action
     */
    public final EventPublisherBlock publish(String publisherName, String message) {
        Block publisherBlock = VFLFlowHelper.CreateBlockAndPush2Buffer(
                publisherName,
                getContext().blockInfo.getId(),
                getBuffer()
        );
        VFLFlowHelper.CreateLogAndPush2Buffer(
                getContext().blockInfo.getId(),
                getContext().currentLogId,
                message,
                publisherBlock.getId(),
                LogTypeBlockStartEnum.PUBLISH_EVENT,
                getBuffer()
        );
        getContext().currentLogId = publisherBlock.getId();
        return new EventPublisherBlock(publisherBlock);
    }

    /**
     * @return The current logging {@link BlockContext}, provided by subclasses
     */
    protected abstract BlockContext getContext();

    /**
     * @return The {@link VFLBuffer} to receive log entries for this context
     */
    protected abstract VFLBuffer getBuffer();
}



package dev.kuku.vfl.core.dtos;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class BlockEndData {
    private Long endTime;
    private String endMessage;
}


package dev.kuku.vfl.core.dtos;

import dev.kuku.vfl.core.models.Block;

public record EventPublisherBlock(Block block) {
}



package dev.kuku.vfl.core.dtos;

import dev.kuku.vfl.core.models.Block;
import lombok.RequiredArgsConstructor;
import lombok.ToString;

import java.util.concurrent.atomic.AtomicBoolean;

@RequiredArgsConstructor
@ToString
public class BlockContext {
    public final Block blockInfo;
    public final AtomicBoolean blockStarted = new AtomicBoolean(false);
    public String currentLogId;
}



package dev.kuku.vfl.core.helpers;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.Log;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;
import dev.kuku.vfl.core.models.logs.enums.LogTypeBlockStartEnum;
import dev.kuku.vfl.core.models.logs.enums.LogTypeEnum;
import dev.kuku.vfl.core.VFL;

import java.time.Instant;
import java.util.function.Function;
import java.util.function.Supplier;

import static dev.kuku.vfl.core.helpers.VFLHelper.UID;

public class VFLFlowHelper {

    public static Log CreateLogAndPush2Buffer(String blockId, String parentLogId, LogTypeEnum logType, String message, VFLBuffer buffer) {
        Log l = new Log(UID(), blockId, parentLogId, logType, message, Instant.now().toEpochMilli());
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static SubBlockStartLog CreateLogAndPush2Buffer(String blockId, String parentLogId, String startMessage, String referencedBlockId, LogTypeBlockStartEnum logType, VFLBuffer buffer) {
        SubBlockStartLog l = new SubBlockStartLog(UID(), blockId, parentLogId, startMessage, referencedBlockId, logType);
        buffer.pushLogToBuffer(l);
        return l;
    }

    public static Block CreateBlockAndPush2Buffer(String blockName, String parentBlockId, VFLBuffer buffer) {
        Block b = new Block(UID(), parentBlockId, blockName);
        buffer.pushBlockToBuffer(b);
        return b;
    }

    public static <R> R CallFnWithLogger(Supplier<R> supplier, VFL logger, Function<R, String> endMessageSerializer) {
        R result = null;
        try {
            result = supplier.get();
            return result;
        } catch (Exception e) {
            logger.error("Exception occurred: " + e.getClass().getSimpleName() + ": " + e.getMessage());
            throw e;
        } finally {
            String endMsg = CreateEndMessage(result, endMessageSerializer);
            logger.close(endMsg);
        }
    }

    private static <R> String CreateEndMessage(R result, Function<R, String> serializer) {
        if (serializer == null) return null;

        try {
            return serializer.apply(result);
        } catch (Exception e) {
            return "Failed to serialize end message: " + e.getMessage();
        }
    }


}


package dev.kuku.vfl.core.helpers;

import dev.kuku.vfl.impl.annotation.SubBlock;

import java.lang.reflect.Method;
import java.util.UUID;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utility methods for Visual Flow Logger (VFL) operations.
 *
 * <p>This class centralizes:
 * <ul>
 *   <li>String/message formatting</li>
 *   <li>Argument and return-value placeholder resolution</li>
 *   <li>Thread info helpers</li>
 *   <li>ID trimming</li>
 * </ul>
 */
public class VFLHelper {

    // Regex for {0}, {1}, etc.
    private static final Pattern PLACEHOLDER_PATTERN = Pattern.compile("\\{(\\d+)}");
    // Regex for {r} or {return} placeholders
    private static final Pattern RETURN_PLACEHOLDER_PATTERN =
            Pattern.compile("\\{r(?:eturn)?}", Pattern.CASE_INSENSITIVE);

    public static String UID() {
        return UUID.randomUUID().toString();
    }

    /**
     * Formats a SLF4J-style message string with "{}" placeholders.
     */
    public static String FormatMessage(String message, Object... args) {
        if (args == null || args.length == 0 || message == null) {
            return message;
        }

        String result = message;
        for (Object arg : args) {
            if (result.contains("{}")) {
                result = result.replaceFirst("\\{}",
                        arg == null ? "null" : String.valueOf(arg));
            } else {
                break;
            }
        }
        return result;
    }

    /**
     * Combines user arguments with a return value into a single array.
     */
    public static Object[] CombineArgsWithReturn(Object[] userArgs, Object returnValue) {
        if (userArgs == null) {
            return new Object[]{returnValue};
        }
        Object[] combined = new Object[userArgs.length + 1];
        System.arraycopy(userArgs, 0, combined, 0, userArgs.length);
        combined[userArgs.length] = returnValue;
        return combined;
    }

    public static String GetThreadInfo() {
        Thread currentThread = Thread.currentThread();
        return String.format("[Thread: %s (ID: %d)]", currentThread.getName(), currentThread.threadId());
    }

    public static String TrimId(String fullId) {
        if (fullId == null) return "null";
        String[] parts = fullId.split("-");
        return parts.length > 0 ? parts[parts.length - 1] : fullId;
    }

    public static <R> Function<R, String> UpdateEndMsg(Function<R, String> msgSerializer, Object... args) {
        return (r) -> {
            String messageTemplate = msgSerializer.apply(r);
            Object[] allArgs = VFLHelper.CombineArgsWithReturn(args, r);
            return VFLHelper.FormatMessage(messageTemplate, allArgs);
        };
    }

    /**
     * Replace {0}, {1}, etc. placeholders with argument values.
     */
    public static String ReplaceArgPlaceholders(String text, Object[] args) {
        if (text == null || args == null || args.length == 0) {
            return text;
        }
        Matcher matcher = PLACEHOLDER_PATTERN.matcher(text);
        StringBuilder sb = new StringBuilder();
        while (matcher.find()) {
            int index;
            try {
                index = Integer.parseInt(matcher.group(1));
            } catch (NumberFormatException e) {
                continue;
            }
            String replacement;
            if (index >= 0 && index < args.length) {
                Object arg = args[index];
                replacement = (arg == null) ? "null" : arg.toString();
            } else {
                replacement = matcher.group(0);
            }
            matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }

    /**
     * Replace {r} or {return} placeholders with the string value of the return object.
     */
    public static String ReplaceReturnPlaceholder(String text, Object returnedValue) {
        if (text == null) {
            return null;
        }
        String replacement = (returnedValue == null) ? "null" : returnedValue.toString();
        return RETURN_PLACEHOLDER_PATTERN.matcher(text)
                .replaceAll(Matcher.quoteReplacement(replacement));
    }

    /**
     * Resolves block name from annotation or method signature.
     */
    public static String ResolveBlockName(Method method, Object[] args) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        String rawName = (annotation != null && isValid(annotation.blockName()))
                ? annotation.blockName().trim()
                : GetMethodName(method, args);
        return ReplaceArgPlaceholders(rawName, args);
    }

    /**
     * Resolves start message from annotation.
     */
    public static String ResolveStartMessage(Method method, Object[] args) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        if (annotation != null && isValid(annotation.startMessage())) {
            String msg = annotation.startMessage().trim();
            return ReplaceArgPlaceholders(msg, args);
        }
        return null;
    }

    /**
     * Resolves end message from annotation with added return value.
     */
    public static String ResolveEndMessage(Method method, Object[] args, Object returnedValue) {
        SubBlock annotation = method.getAnnotation(SubBlock.class);
        if (annotation != null && isValid(annotation.endMessage())) {
            String msg = annotation.endMessage().trim();
            msg = ReplaceArgPlaceholders(msg, args);
            msg = ReplaceReturnPlaceholder(msg, returnedValue);
            return msg;
        }
        return null;
    }

    private static boolean isValid(String str) {
        return str != null && !str.trim().isEmpty();
    }

    public static String GetMethodName(Method method, Object[] args) {
        StringBuilder sb = new StringBuilder(method.getName()).append('(');
        if (args != null) {
            for (int i = 0; i < args.length; i++) {
                if (i > 0) sb.append(", ");
                sb.append(args[i]);
            }
        }
        return sb.append(')').toString();
    }
}



package dev.kuku.vfl.core.buffer.flushHandler;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import dev.kuku.vfl.core.models.logs.SubBlockStartLog;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * VFLFlushHandler implementation that generates nested JSON output showing hierarchical execution flow.
 * Creates a single JSON file with blocks and their nested log chains based on parent-child relationships.
 * NOT RECOMMENDED for production. Only use during development and testing.
 */
public class NestedJsonFlushHandler implements VFLFlushHandler {

    private final String outputFilePath;
    private final ObjectMapper objectMapper;
    private final DateTimeFormatter timeFormatter;

    // Data storage
    private final Map<String, Block> blocks = new ConcurrentHashMap<>();
    private final Map<String, Log> logs = new ConcurrentHashMap<>();
    private final Map<String, Long> blockStarts = new ConcurrentHashMap<>();
    private final Map<String, BlockEndData> blockEnds = new ConcurrentHashMap<>();

    public NestedJsonFlushHandler(String outputFilePath) {
        this.outputFilePath = outputFilePath;
        this.objectMapper = new ObjectMapper();
        this.objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        this.timeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
                .withZone(ZoneId.systemDefault());
    }

    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        if (logs != null) {
            for (Log log : logs) {
                this.logs.put(log.getId(), log);
            }
        }
        return true;
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        if (blocks != null) {
            for (Block block : blocks) {
                this.blocks.put(block.getId(), block);
            }
        }
        return true;
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        if (blockStarts != null) {
            this.blockStarts.putAll(blockStarts);
        }
        return true;
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        if (blockEnds != null) {
            this.blockEnds.putAll(blockEnds);
        }
        return true;
    }

    @Override
    public void closeFlushHandler() {
        try {
            List<BlockJson> rootBlocks = buildNestedStructure();
            writeJsonToFile(rootBlocks);
        } catch (Exception e) {
            throw new RuntimeException("Failed to generate nested JSON output", e);
        }
    }


    private List<BlockJson> buildNestedStructure() {
        // Find root blocks (blocks with no parent)
        List<Block> rootBlocksList = blocks.values().stream()
                .filter(block -> block.getParentBlockId() == null)
                .toList();

        List<BlockJson> result = new ArrayList<>();
        for (Block rootBlock : rootBlocksList) {
            result.add(buildBlockJson(rootBlock));
        }

        return result;
    }

    private BlockJson buildBlockJson(Block block) {
        BlockJson blockJson = new BlockJson();
        blockJson.blockId = block.getId();
        blockJson.parentBlockId = block.getParentBlockId();
        blockJson.name = block.getBlockName();

        // Format times and calculate duration
        Long startTime = blockStarts.get(block.getId());
        if (startTime != null) {
            blockJson.startTime = formatTime(startTime);
        }

        // Handle block end time and calculate duration
        BlockEndData blockEnd = blockEnds.get(block.getId());
        if (blockEnd != null) {
            blockJson.endTime = formatTime(blockEnd.getEndTime());
            blockJson.endMessage = blockEnd.getEndMessage();

            // Calculate duration if both start and end times are available
            if (startTime != null) {
                long duration = blockEnd.getEndTime() - startTime;
                blockJson.duration = formatDuration(duration);
            }
        }

        // Build logs chain for this block
        blockJson.logsChain = buildLogsChain(block.getId(), null);

        return blockJson;
    }

    private List<LogJson> buildLogsChain(String blockId, String parentLogId) {
        // Get all logs for this block with the specified parent log ID
        List<Log> blockLogs = logs.values().stream()
                .filter(log -> Objects.equals(log.getBlockId(), blockId))
                .filter(log -> Objects.equals(log.getParentLogId(), parentLogId))
                .sorted(Comparator.comparing(Log::getTimestamp))
                .toList();

        List<LogJson> logJsons = new ArrayList<>();

        for (Log log : blockLogs) {
            LogJson logJson = new LogJson();
            logJson.id = log.getId();
            logJson.type = log.getLogType().toString();
            logJson.message = log.getMessage();
            logJson.timestamp = formatTime(log.getTimestamp());

            // Handle SubBlockStartLog special case
            if (log instanceof SubBlockStartLog subBlockLog) {
                String referencedBlockId = subBlockLog.getReferencedBlockId();

                // Add duration and end message for sub-block logs
                Long subBlockStartTime = blockStarts.get(referencedBlockId);
                BlockEndData subBlockEnd = blockEnds.get(referencedBlockId);

                if (subBlockStartTime != null && subBlockEnd != null) {
                    long duration = subBlockEnd.getEndTime() - subBlockStartTime;
                    logJson.duration = formatDuration(duration);
                    logJson.endMessage = subBlockEnd.getEndMessage();
                }

                // Add referenced block
                Block referencedBlock = blocks.get(referencedBlockId);
                if (referencedBlock != null) {
                    logJson.referencedBlock = buildBlockJson(referencedBlock);
                }
            }

            // Build nested logs chain (logs that have this log as parent)
            List<LogJson> nestedLogs = buildLogsChain(blockId, log.getId());
            if (!nestedLogs.isEmpty()) {
                logJson.logsChain = nestedLogs;
            }

            logJsons.add(logJson);
        }

        return logJsons;
    }

    private String formatTime(long timestampMillis) {
        return timeFormatter.format(Instant.ofEpochMilli(timestampMillis));
    }

    private String formatDuration(long durationMillis) {
        if (durationMillis < 1000) {
            return durationMillis + "ms";
        } else if (durationMillis < 60000) {
            double seconds = durationMillis / 1000.0;
            return String.format("%.3fs", seconds);
        } else {
            long minutes = durationMillis / 60000;
            long remainingMs = durationMillis % 60000;
            double remainingSeconds = remainingMs / 1000.0;
            return String.format("%dmin %.3fs", minutes, remainingSeconds);
        }
    }

    private void writeJsonToFile(List<BlockJson> rootBlocks) throws IOException {
        File outputFile = new File(outputFilePath);

        // Create parent directories if they don't exist
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            if (!parentDir.mkdirs()) {
                throw new IOException("Failed to create parent directories for: " + outputFilePath);
            }
        }

        try (FileWriter writer = new FileWriter(outputFile)) {
            objectMapper.writeValue(writer, rootBlocks);
        }
    }

    // JSON data classes
    private static class BlockJson {
        public String blockId;
        public String parentBlockId;
        public String name;
        public String startTime;
        public String endTime;
        public String duration;
        public String endMessage;
        public List<LogJson> logsChain;
    }

    private static class LogJson {
        public String id;
        public String type;
        public String message;
        public String timestamp;
        public String duration; // Only for SubBlockStartLog
        public String endMessage; // Only for SubBlockStartLog
        public BlockJson referencedBlock; // Only for SubBlockStartLog
        public List<LogJson> logsChain; // Nested logs
    }

    @Override
    public String toString() {
        return "NestedJsonFlushHandler{" +
                "blocks=" + blocks +
                ", logs=" + logs +
                '}';
    }
}


package dev.kuku.vfl.core.buffer.flushHandler;

import com.fasterxml.jackson.databind.ObjectMapper;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Map;

/**
 * VFL flush handler that sends batched logs and blocks to a VFL Hub via blocking HTTP calls.
 *
 * <p>This implementation uses the Java 11+ {@link HttpClient} in blocking mode to ensure requests
 * are sent in order. This blocking behavior is suitable when order matters for the log data.
 * When used with an asynchronous buffer like {@link dev.kuku.vfl.core.buffer.AsyncBuffer},
 * the blocking calls run in a separate executor thread and do not block the main application.
 *
 * <p><b>Features:</b>
 * <ul>
 *   <li>Serializes data to JSON using Jackson {@link ObjectMapper}</li>
 *   <li>Performs POST requests to configured endpoints for logs, blocks, block starts, and block ends</li>
 *   <li>Logs detailed debug and warning information on each request and response</li>
 *   <li>Retries and error handling are left to the caller or upper layers</li>
 * </ul>
 *
 * <p><b>Usage:</b> Instantiate with the base URI of your VFL Hub endpoint (e.g., "<a href="http://host:port">http://localhost:8080</a>").
 * This handler can then be passed to a {@link dev.kuku.vfl.core.buffer.VFLBuffer} implementation
 * that supports flushing.</p>
 */
@Slf4j
@RequiredArgsConstructor
public class VFLHubFlushHandler implements VFLFlushHandler {

    private static final String ADD_LOGS_EP = "/logs";
    private static final String ADD_BLOCKS_EP = "/blocks";
    private static final String ADD_BLOCK_STARTS_EP = "/block-starts";
    private static final String ADD_BLOCK_ENDS_EP = "/block-ends";
    private static final String API_VERSION = "api/v1";

    private final URI url;
    private final HttpClient httpClient = HttpClient.newBuilder().build();
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        return postData(logs, ADD_LOGS_EP, "logs");
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        return postData(blocks, ADD_BLOCKS_EP, "blocks");
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        return postData(blockStarts, ADD_BLOCK_STARTS_EP, "block starts");
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        return postData(blockEnds, ADD_BLOCK_ENDS_EP, "block ends");
    }

    private <T> boolean postData(T data, String endpoint, String dataDescription) {
        log.debug("Attempting to push {} {} to server", (data instanceof List<?> ? ((List<?>) data).size() : ((Map<?, ?>) data).size()), dataDescription);
        try {
            String jsonBody = objectMapper.writeValueAsString(data);
            log.trace("Serialized {} to JSON: {} characters", dataDescription, jsonBody.length());

            String fullUrl = url.toString() + "/" + API_VERSION + endpoint;
            HttpRequest request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
                    .uri(URI.create(fullUrl))
                    .header("Content-Type", "application/json")
                    .build();

            log.debug("Sending POST request to: {}", fullUrl);
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            boolean success = response.statusCode() >= 200 && response.statusCode() < 300;
            if (success) {
                log.debug("Successfully pushed {} to server. Status: {}", dataDescription, response.statusCode());
            } else {
                log.warn("Failed to push {} to server. Status: {}, Response: {}", dataDescription, response.statusCode(), response.body());
            }

            return success;
        } catch (IOException | InterruptedException e) {
            log.error("Error pushing {} to server", dataDescription, e);
            return false;
        }
    }

    @Override
    public void closeFlushHandler() {
        // The java.net.http.HttpClient does not require explicit shutdown.
        // Resources will be cleaned up automatically.
    }
}



package dev.kuku.vfl.core.buffer.flushHandler;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

/**
 * Destination handler for flushing batched VFL trace data.
 *
 * <p>Implementations of this interface are responsible for taking
 * batches of logs, blocks, and lifecycle events from a {@link dev.kuku.vfl.core.buffer.VFLBuffer}
 * (e.g., {@link dev.kuku.vfl.core.buffer.SynchronousBuffer} or
 * {@link dev.kuku.vfl.core.buffer.AsyncBuffer}) and delivering them
 * to a final destination such as a remote server, message queue, database, or file system.
 *
 * <h2>Contract:</h2>
 * <ul>
 *   <li>Each method receives a <b>batch snapshot</b> of data to send.</li>
 *   <li>Must be <b>thread‚Äësafe</b> ‚Äî buffers may flush from multiple threads concurrently.</li>
 *   <li>Return {@code true} if the data was successfully delivered, {@code false} for a recoverable failure
 *       (allowing buffer policies to retry if implemented).</li>
 *   <li>Methods must return promptly ‚Äî avoid long blocking unless acceptable by design (e.g., in synchronous flushing).</li>
 * </ul>
 *
 * <h2>Flush Ordering:</h2>
 * Buffers may use {@code performOrderedFlush()} to ensure flushing happens in this sequence:
 * <ol>
 *     <li>{@link #pushBlocksToServer(List)}</li>
 *     <li>{@link #pushBlockStartsToServer(Map)}</li>
 *     <li>{@link #pushBlockEndsToServer(Map)}</li>
 *     <li>{@link #pushLogsToServer(List)}</li>
 * </ol>
 * This ensures all references (IDs) exist before related events are sent.
 *
 * <h2>Lifecycle:</h2>
 * <ul>
 *   <li>{@link #closeFlushHandler()} will be called during shutdown to release resources
 *       (e.g., close network connections, stop threads).</li>
 *   <li>Implementers should make {@code closeFlushHandler()} idempotent and safe to call multiple times.</li>
 * </ul>
 */
public interface VFLFlushHandler {

    /**
     * Push a batch of logs to the destination.
     *
     * @param logs list of log entries to send
     * @return true if successfully delivered, false otherwise
     */
    boolean pushLogsToServer(List<Log> logs);

    /**
     * Push a batch of block definitions to the destination.
     *
     * @param blocks block metadata to send
     * @return true if successfully delivered, false otherwise
     */
    boolean pushBlocksToServer(List<Block> blocks);

    /**
     * Push a mapping of block IDs to their start timestamps.
     *
     * @param blockStarts map where key = blockId, value = epoch millis start time
     * @return true if successfully delivered, false otherwise
     */
    boolean pushBlockStartsToServer(Map<String, Long> blockStarts);

    /**
     * Push a mapping of block IDs to their end data.
     *
     * @param blockEnds map where key = blockId, value = end metadata (timestamp + optional message)
     * @return true if successfully delivered, false otherwise
     */
    boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds);

    /**
     * Release any resources used by this flush handler.
     * <p>Called once during shutdown; should close connections and stop background tasks.</p>
     */
    void closeFlushHandler();
}



package dev.kuku.vfl.core.buffer.flushHandler;

import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

public class NoOpsFlushHandler implements VFLFlushHandler {
    @Override
    public boolean pushLogsToServer(List<Log> logs) {
        return true;
    }

    @Override
    public boolean pushBlocksToServer(List<Block> blocks) {
        return true;
    }

    @Override
    public boolean pushBlockStartsToServer(Map<String, Long> blockStarts) {
        return true;
    }

    @Override
    public boolean pushBlockEndsToServer(Map<String, BlockEndData> blockEnds) {
        return true;
    }

    @Override
    public void closeFlushHandler() {

    }
}



package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.buffer.abstracts.VFLBufferWithFlushHandlerBase;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Asynchronous buffer implementation of {@link VFLBuffer} that batches log and block data
 * and flushes it asynchronously using an {@link ExecutorService}.
 *
 * <p>This buffer also supports periodic flushing at a fixed interval using a {@link ScheduledExecutorService}.
 * Data is flushed in batches when the buffer is full or at the periodic interval, whichever comes first.
 *
 * <p><b>Main features:</b>
 * <ul>
 *   <li>Batches incoming logs, blocks, and start/end events for efficient flushing</li>
 *   <li>Flushes buffered data asynchronously via a provided {@link ExecutorService}</li>
 *   <li>Periodically flushes at a configurable interval via a scheduled executor</li>
 *   <li>Gracefully shuts down executors and flushes all pending data on {@link #flush()}</li>
 *   <li>Falls back to synchronous flush if the executor rejects tasks (e.g., during shutdown)</li>
 * </ul>
 *
 * <p><b>Usage notes:</b>
 * <ul>
 *   <li>The {@code flushTimeout} controls how long the buffer waits for async flush tasks
 *       to complete during {@link #flush()} shutdown before forcing a shutdown</li>
 *   <li>Construct with your own configured executors and flush handler implementation</li>
 *   <li>Make sure to call {@link #flush()} at shutdown to avoid losing buffered data</li>
 * </ul>
 */
@Slf4j
public class AsyncBuffer extends VFLBufferWithFlushHandlerBase {

    private final ExecutorService flushExecutor;
    private final ScheduledExecutorService periodicExecutor;
    private final int flushTimeout;

    /**
     * Constructs an AsyncBuffer instance.
     *
     * @param bufferSize               max number of buffered items before automatic flush
     * @param finalFlushTimeoutMillisecond max millis to wait for async flush tasks to complete on shutdown
     * @param periodicFlushTimeMillisecond interval in millis to trigger periodic flushes
     * @param flushHandler             handler responsible for sending flushed data to destination
     * @param bufferFlushExecutor      executor for async flush task execution
     * @param periodicFlushExecutor    scheduled executor for periodic flush triggers
     */
    public AsyncBuffer(int bufferSize,
                       int finalFlushTimeoutMillisecond,
                       int periodicFlushTimeMillisecond,
                       VFLFlushHandler flushHandler,
                       ExecutorService bufferFlushExecutor,
                       ScheduledExecutorService periodicFlushExecutor) {
        super(bufferSize, flushHandler);
        this.flushExecutor = bufferFlushExecutor;
        this.periodicExecutor = periodicFlushExecutor;
        this.flushTimeout = finalFlushTimeoutMillisecond;

        // Schedule periodic flushes at fixed delay
        periodicExecutor.scheduleWithFixedDelay(this::flushAll,
                periodicFlushTimeMillisecond,
                periodicFlushTimeMillisecond,
                TimeUnit.MILLISECONDS);
    }

    /**
     * Executes the flush asynchronously using the flush executor.
     * If the executor is shut down or rejects the task, performs a synchronous flush.
     */
    @Override
    protected void executeFlushAll(List<Log> logs,
                                   List<Block> blocks,
                                   Map<String, Long> blockStarts,
                                   Map<String, BlockEndData> blockEnds) {
        if (flushExecutor.isShutdown()) {
            log.warn("Executor is shutdown, performing synchronous flush");
            performOrderedFlush(logs, blocks, blockStarts, blockEnds);
            return;
        }

        try {
            flushExecutor.submit(() -> performOrderedFlush(logs, blocks, blockStarts, blockEnds));
        } catch (RejectedExecutionException e) {
            log.warn("Task rejected by executor (likely shutting down), performing synchronous flush", e);
            performOrderedFlush(logs, blocks, blockStarts, blockEnds);
        }
    }

    /**
     * Flushes all remaining data, shuts down executors with a timeout,
     * and closes the flush handler.
     *
     * @throws RuntimeException if the flush executor did not terminate within the timeout
     */
    @Override
    public void flush() {
        // Stop periodic flushes to avoid race conditions during shutdown
        periodicExecutor.shutdown();

        // Flush any buffered data
        super.flushAll();

        // Shutdown flush executor and wait for tasks to complete
        flushExecutor.shutdown();

        try {
            int elapsed = 0;
            while (elapsed < flushTimeout) {
                if (flushExecutor.awaitTermination(100, TimeUnit.MILLISECONDS)) {
                    log.debug("Finished flush executor shutdown. Closing flush handler.");
                    flushHandler.closeFlushHandler();
                    log.debug("Finished complete flush");
                    return;
                }
                elapsed += 100;
            }

            // Timeout reached - force shutdown and report error
            flushExecutor.shutdownNow();
            throw new RuntimeException("Flush timeout exceeded: " + flushTimeout + "ms");
        } catch (InterruptedException e) {
            flushExecutor.shutdownNow();
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted during shutdown", e);
        }
    }

    @Override
    public String toString() {
        return "AsyncBuffer{" +
                "flushTimeout=" + flushTimeout +
                ", flushHandler=" + flushHandler +
                ", periodicExecutor=" + periodicExecutor +
                ", flushExecutor=" + flushExecutor +
                '}';
    }
}



package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.buffer.abstracts.VFLBufferWithFlushHandlerBase;
import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

/**
 * A {@link dev.kuku.vfl.core.buffer.VFLBuffer} implementation that flushes data
 * <b>synchronously</b> in the calling thread.
 *
 * <p>When the buffer is full (or {@link #flush()} is called), any collected logs, blocks,
 * and block lifecycle events are sent immediately to the configured {@link VFLFlushHandler}.
 * The call will block until the destination processing is completed.</p>
 *
 * <h2>Key characteristics:</h2>
 * <ul>
 *   <li>Simple, predictable execution ‚Äî no background threads</li>
 *   <li>Flush overhead is paid by the thread calling the flush</li>
 *   <li>Useful when:
 *     <ul>
 *       <li>You require guaranteed ordering and delivery before proceeding</li>
 *       <li>You prefer minimal concurrency complexity</li>
 *       <li>Logs volume is small and latency is acceptable</li>
 *     </ul>
 *   </li>
 *   <li>Not recommended if flush operations involve slow I/O or heavy processing,
 *       as this will directly impact caller performance</li>
 * </ul>
 *
 * <h2>Example:</h2>
 * <pre>{@code
 * VFLFlushHandler handler = new MyHttpFlushHandler();
 * VFLBuffer buffer = new SynchronousBuffer(100, handler);
 * // Pass this buffer into your VFL initializer config
 * }</pre>
 */
public class SynchronousBuffer extends VFLBufferWithFlushHandlerBase {

    /**
     * @param bufferSize   Max number of buffered items before auto-flush
     * @param flushHandler Destination handler that will receive flushed data
     */
    public SynchronousBuffer(int bufferSize, VFLFlushHandler flushHandler) {
        super(bufferSize, flushHandler);
    }

    /**
     * Performs a blocking flush in the calling thread
     * by directly invoking {@link #performOrderedFlush(List, List, Map, Map)}.
     */
    @Override
    protected void executeFlushAll(List<Log> logs,
                                   List<Block> blocks,
                                   Map<String, Long> blockStarts,
                                   Map<String, BlockEndData> blockEnds) {
        performOrderedFlush(logs, blocks, blockStarts, blockEnds);
    }
}



package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

/**
 * Abstraction for buffering Visual Flow Logger (VFL) trace data.
 *
 * <p>Implementations of this interface are responsible for temporarily
 * storing blocks and log entries generated during execution, before
 * they are persisted, sent over the network, or otherwise processed.
 *
 * <p>VFL calls these methods in a <b>fire-and-forget</b> manner ‚Äî
 * your implementation must be thread‚Äësafe and non‚Äëblocking as much as possible.
 * Slow or blocking implementations can negatively affect application performance.
 *
 * <h2>Typical Implementations:</h2>
 * <ul>
 *   <li>In‚Äëmemory async buffer with background flush to a datastore</li>
 *   <li>Direct streaming of entries to Kafka or another message broker</li>
 *   <li>Writing to a local file for offline analysis</li>
 * </ul>
 *
 * <h2>Thread Safety:</h2>
 * Implementations <b>must</b> be safe for concurrent calls from
 * multiple application threads.
 */
public interface VFLBuffer {

    /**
     * Buffer a single log entry for the current block.
     *
     * <p>Called whenever the user logs a message (INFO/WARN/ERROR, etc.).
     * Should enqueue or persist the log entry without blocking the caller.
     *
     * @param log the log entry to store
     */
    void pushLogToBuffer(Log log);

    /**
     * Buffer a block creation event.
     *
     * <p>Called whenever a new block is created (root, sub-block,
     * continuation, event listener, etc.).
     *
     * @param block the block metadata to store
     */
    void pushBlockToBuffer(Block block);

    /**
     * Buffer the "start" event for an existing block with its timestamp.
     *
     * <p>Called when VFL marks a block as started
     * (before any log messages are written to it).
     *
     * @param blockId   ID of the block being started
     * @param timestamp epoch millis of the start time
     */
    void pushLogStartToBuffer(String blockId, long timestamp);

    /**
     * Buffer the "end" event for an existing block.
     *
     * <p>Called when a block is closed, typically including
     * its end timestamp and optional final message.
     *
     * @param blockId  ID of the block being ended
     * @param endData  contains timestamp and optional end message
     */
    void pushLogEndToBuffer(String blockId, BlockEndData endData);

    /**
     * Flush all pending blocks/logs and release resources.
     *
     * <p>Called at the end of a root block or during shutdown.
     * Implementations should ensure all buffered data is safely persisted
     * before returning.
     */
    void flush();
}



package dev.kuku.vfl.core.buffer.abstracts;

import dev.kuku.vfl.core.buffer.flushHandler.VFLFlushHandler;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.List;
import java.util.Map;

/**
 * Abstract extension of {@link VFLBufferBase} that integrates with a {@link VFLFlushHandler}.
 *
 * <p>This provides the common structure for VFL buffers that:
 * <ul>
 *   <li>Batch incoming blocks, logs, and start/end events (via {@link VFLBufferBase})</li>
 *   <li>Use a {@link VFLFlushHandler} to actually send these batched items to a destination
 *       such as a server, message queue, or file store</li>
 *   <li>Allow subclasses to decide the execution strategy (synchronous, asynchronous, threaded, etc.)</li>
 * </ul>
 *
 * <h2>Key Points:</h2>
 * <ul>
 *   <li>{@link #executeFlushAll(List, List, Map, Map)} must be implemented by subclasses
 *       to define how the flush will be performed.</li>
 *   <li>{@link #performOrderedFlush(List, List, Map, Map)} is provided as a utility
 *       to flush in the correct sequence:
 *       <ol>
 *           <li>Blocks (structure)</li>
 *           <li>Block start events (timestamps)</li>
 *           <li>Block end events (timestamps + end messages)</li>
 *           <li>Log entries (messages)</li>
 *       </ol>
 *   </li>
 *   <li>{@link #flush()} closes the flush handler after flushing remaining data ‚Äî
 *       suitable for shutdown hooks.</li>
 * </ul>
 *
 * <h2>Typical Usage:</h2>
 * <pre>{@code
 * public class AsyncHttpVFLBuffer extends VFLBufferWithFlushHandlerBase {
 *     public AsyncHttpVFLBuffer(int size, VFLFlushHandler handler) {
 *         super(size, handler);
 *     }
 *
 *     @Override
 *     protected void executeFlushAll(List<Log> logs,
 *                                     List<Block> blocks,
 *                                     Map<String, Long> blockStarts,
 *                                     Map<String, BlockEndData> blockEnds) {
 *         // Example: send in another thread
 *         executor.submit(() -> performOrderedFlush(logs, blocks, blockStarts, blockEnds));
 *     }
 * }
 * }</pre>
 */
public abstract class VFLBufferWithFlushHandlerBase extends VFLBufferBase {

    /** Responsible for pushing buffered data to the destination (e.g., server, DB, queue) */
    protected final VFLFlushHandler flushHandler;

    /**
     * @param bufferSize   maximum combined items before triggering automatic flush
     * @param flushHandler handler that knows how to send the batched data to its destination
     */
    public VFLBufferWithFlushHandlerBase(int bufferSize, VFLFlushHandler flushHandler) {
        super(bufferSize);
        this.flushHandler = flushHandler;
    }

    /**
     * Final override from {@link VFLBufferBase} that delegates the
     * flush operation to {@link #executeFlushAll(List, List, Map, Map)}.
     */
    @Override
    protected final void onFlushAll(List<Log> logs,
                                    List<Block> blocks,
                                    Map<String, Long> blockStarts,
                                    Map<String, BlockEndData> blockEnds) {
        executeFlushAll(logs, blocks, blockStarts, blockEnds);
    }

    /**
     * Flush remaining data and close the flush handler.
     * <p>Intended to be called during graceful shutdown.</p>
     */
    @Override
    public void flush() {
        super.flush(); // Flush any pending batches
        flushHandler.closeFlushHandler(); // Cleanup flush handler resources
    }

    /**
     * Subclasses must implement this to define how the flush operation will be performed.
     *
     * @param logs        snapshot of logs to send
     * @param blocks      snapshot of blocks to send
     * @param blockStarts snapshot of block start timestamps
     * @param blockEnds   snapshot of block end data
     */
    protected abstract void executeFlushAll(List<Log> logs,
                                            List<Block> blocks,
                                            Map<String, Long> blockStarts,
                                            Map<String, BlockEndData> blockEnds);

    /**
     * Convenience method to flush in correct dependency order:
     * <ol>
     *     <li>Blocks ‚Üí parent structure for events/logs</li>
     *     <li>Block starts ‚Üí mark when blocks began</li>
     *     <li>Block ends ‚Üí mark when blocks finished</li>
     *     <li>Logs ‚Üí messages linked to existing blocks</li>
     * </ol>
     * Subclasses can call this from {@link #executeFlushAll(List, List, Map, Map)}
     * to enforce ordering.
     */
    protected final void performOrderedFlush(List<Log> logs,
                                             List<Block> blocks,
                                             Map<String, Long> blockStarts,
                                             Map<String, BlockEndData> blockEnds) {
        if (!blocks.isEmpty()) {
            flushHandler.pushBlocksToServer(blocks);
        }
        if (!blockStarts.isEmpty()) {
            flushHandler.pushBlockStartsToServer(blockStarts);
        }
        if (!blockEnds.isEmpty()) {
            flushHandler.pushBlockEndsToServer(blockEnds);
        }
        if (!logs.isEmpty()) {
            flushHandler.pushLogsToServer(logs);
        }
    }
}



package dev.kuku.vfl.core.buffer.abstracts;

import dev.kuku.vfl.core.buffer.VFLBuffer;
import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Base implementation of {@link VFLBuffer} with in‚Äëmemory, size‚Äëbased batching.
 *
 * <p>This abstract class provides:
 * <ul>
 *     <li>Thread‚Äësafe storage of incoming logs, blocks, and block start/end events</li>
 *     <li>Automatic flush when the total buffered item count exceeds the configured {@code bufferSize}</li>
 *     <li>A single {@link #onFlushAll(List, List, Map, Map)} callback point for subclasses
 *         to perform actual persistence or forwarding</li>
 * </ul>
 *
 * <h2>How flushing works</h2>
 * <ol>
 *   <li>Incoming push methods ({@code pushLogToBuffer}, {@code pushBlockToBuffer}, etc.)
 *       store the event in an internal collection.</li>
 *   <li>If the total number of buffered items exceeds {@code bufferSize},
 *       {@link #flushAll()} is triggered automatically.</li>
 *   <li>{@code flushAll()} copies and clears the internal collections under a lock, then
 *       calls {@link #onFlushAll(List, List, Map, Map)} without holding the lock.</li>
 *   <li>Multiple flushes can run concurrently ‚Äî each gets its own copy of the data to handle.</li>
 * </ol>
 *
 * <h2>Thread Safety</h2>
 * <ul>
 *   <li>All buffer mutations are guarded by a {@link ReentrantLock}.</li>
 *   <li>The {@code onFlushAll} method is called without any locks, so implementations must be
 *       thread‚Äësafe if they mutate shared resources.</li>
 * </ul>
 *
 * <h2>Extending this class</h2>
 * To create a custom buffer, extend this class and implement {@link #onFlushAll(List, List, Map, Map)}:
 * <pre>{@code
 * public class ConsoleVFLBuffer extends VFLBufferBase {
 *     public ConsoleVFLBuffer(int bufferSize) {
 *         super(bufferSize);
 *     }
 *
 *     @Override
 *     protected void onFlushAll(List<Log> logs,
 *                               List<Block> blocks,
 *                               Map<String, Long> blockStarts,
 *                               Map<String, BlockEndData> blockEnds) {
 *         logs.forEach(l -> System.out.println("LOG: " + l));
 *         blocks.forEach(b -> System.out.println("BLOCK: " + b));
 *         blockStarts.forEach((id, ts) -> System.out.println("START: " + id + " -> " + ts));
 *         blockEnds.forEach((id, data) -> System.out.println("END: " + id + " -> " + data));
 *     }
 * }
 * }</pre>
 *
 * <h2>When to call {@link #flush()}</h2>
 * <ul>
 *   <li>Normally, flushing is automatic when the buffer is full</li>
 *   <li>You can manually call {@link #flush()} to force a flush (e.g., at shutdown)</li>
 * </ul>
 */
public abstract class VFLBufferBase implements VFLBuffer {
    private final int bufferSize;
    private final ReentrantLock lock = new ReentrantLock();
    private final List<Log> logs2Flush;
    private final List<Block> blocks2Flush;
    private final Map<String, Long> blockStarts2Flush;
    private final Map<String, BlockEndData> blockEnds2Flush;

    /**
     * @param bufferSize maximum number of total items (logs + blocks + starts + ends)
     *                   to buffer before triggering an automatic flush
     */
    public VFLBufferBase(int bufferSize) {
        this.bufferSize = bufferSize;
        logs2Flush = new ArrayList<>();
        blocks2Flush = new ArrayList<>();
        blockStarts2Flush = new HashMap<>();
        blockEnds2Flush = new HashMap<>();
    }

    @Override
    public void pushLogToBuffer(Log log) {
        lock.lock();
        try {
            this.logs2Flush.add(log);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushBlockToBuffer(Block block) {
        lock.lock();
        try {
            this.blocks2Flush.add(block);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushLogStartToBuffer(String blockId, long timestamp) {
        lock.lock();
        try {
            this.blockStarts2Flush.put(blockId, timestamp);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    @Override
    public void pushLogEndToBuffer(String blockId, BlockEndData endData) {
        lock.lock();
        try {
            blockEnds2Flush.put(blockId, endData);
        } finally {
            lock.unlock();
        }
        flushIfFull();
    }

    /**
     * Checks current buffer size and triggers a flush if over limit.
     */
    private void flushIfFull() {
        boolean shouldFlush = false;
        lock.lock();
        try {
            int totalSize = logs2Flush.size()
                    + blocks2Flush.size()
                    + blockStarts2Flush.size()
                    + blockEnds2Flush.size();
            if (totalSize > bufferSize) {
                shouldFlush = true;
            }
        } finally {
            lock.unlock();
        }
        if (shouldFlush) {
            flushAll();
        }
    }

    /**
     * Copies and clears all pending entries, then calls {@link #onFlushAll(List, List, Map, Map)}.
     * <p>This design avoids holding the lock during slow IO operations in {@code onFlushAll()}.</p>
     */
    protected void flushAll() {
        List<Log> logsToFlush;
        List<Block> blocksToFlush;
        Map<String, Long> blockStartsToFlush;
        Map<String, BlockEndData> blockEndsToFlush;

        lock.lock();
        try {
            logsToFlush = new ArrayList<>(logs2Flush);
            blocksToFlush = new ArrayList<>(blocks2Flush);
            blockStartsToFlush = new HashMap<>(blockStarts2Flush);
            blockEndsToFlush = new HashMap<>(blockEnds2Flush);

            logs2Flush.clear();
            blocks2Flush.clear();
            blockStarts2Flush.clear();
            blockEnds2Flush.clear();
        } finally {
            lock.unlock(); // lock is released before the flush is processed
        }

        // Multiple flush calls can run in parallel, each with its own snapshot
        onFlushAll(logsToFlush, blocksToFlush, blockStartsToFlush, blockEndsToFlush);
    }

    @Override
    public void flush() {
        flushAll();
    }

    /**
     * Called whenever the buffer is flushed (manually or because it is full).
     *
     * <p>Subclasses must implement this method to define how and where the flushed
     * data is sent (e.g., to disk, database, queue, or logging system).</p>
     *
     * @param logs        snapshot of logs to flush
     * @param blocks      snapshot of blocks to flush
     * @param blockStarts snapshot of block start timestamps
     * @param blockEnds   snapshot of block end data
     */
    protected abstract void onFlushAll(List<Log> logs,
                                       List<Block> blocks,
                                       Map<String, Long> blockStarts,
                                       Map<String, BlockEndData> blockEnds);
}



package dev.kuku.vfl.core.buffer;

import dev.kuku.vfl.core.models.Block;
import dev.kuku.vfl.core.dtos.BlockEndData;
import dev.kuku.vfl.core.models.logs.Log;

/**
 * A {@link VFLBuffer} implementation that discards all data.
 *
 * <p>This is a "no‚Äëoperation" (no‚Äëop) buffer ‚Äî all calls to push logs,
 * blocks, or block lifecycle events are ignored, and {@link #flush()} does nothing.</p>
 *
 * <h2>Use cases:</h2>
 * <ul>
 *   <li><b>Disable VFL output</b> completely while keeping the code paths intact</li>
 *   <li>Run unit tests or benchmarks without generating log output</li>
 *   <li>Use as a safe fallback when no actual buffer implementation is configured</li>
 * </ul>
 *
 * <h2>Important:</h2>
 * <ul>
 *   <li>All trace/log data is discarded immediately ‚Äî nothing is written to memory, files, or downstream systems</li>
 *   <li>Intended for scenarios where you explicitly do <b>not</b> need VFL logs or metrics</li>
 * </ul>
 */
public class NoOpsBuffer implements VFLBuffer {

    @Override
    public void pushLogToBuffer(Log log) {
        // Do nothing
    }

    @Override
    public void pushBlockToBuffer(Block block) {
        // Do nothing
    }

    @Override
    public void pushLogStartToBuffer(String blockId, long timestamp) {
        // Do nothing
    }

    @Override
    public void pushLogEndToBuffer(String blockId, BlockEndData endData) {
        // Do nothing
    }

    @Override
    public void flush() {
        // Do nothing
    }
}


